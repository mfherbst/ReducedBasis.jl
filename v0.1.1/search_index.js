var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [ReducedBasis]","category":"page"},{"location":"api/#ReducedBasis.AffineDecomposition","page":"API reference","title":"ReducedBasis.AffineDecomposition","text":"Represents an affine decomposition\n\nO(bmmu) = sum_r=1^R alpha_r(bmmu) O_r\n\nwhere terms<:AbstractArray carries the O_r matrices (or more generally linear maps) and the coefficient_map<:Function implements the alpha_r(bmmu) coefficient functions.\n\nNote that r = (r_1 dots r_d) generally is a multi-index and as such terms can be a d-dimensional array. Correspondingly, coefficient_map maps parameter points bmmu to an size(terms) array.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.AffineDecomposition-Tuple{Any}","page":"API reference","title":"ReducedBasis.AffineDecomposition","text":"(ad::AffineDecomposition{<:AbstractArray{<:ApproxMPO}})(μ)\n\nCompute sum with ApproxMPOs using the exact ITensors operator sum.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.ApproxMPO","page":"API reference","title":"ReducedBasis.ApproxMPO","text":"Carries an ITensors.MPO matrix-product operator and possible truncation keyword arguments.\n\nThis enables a simple mpo * mps syntax while allowing for proper truncation throughout the basis assembly. Includes the exact operator sum in opsum to be able to produce efficient sums of MPOs when constructing AffineDecomposition sums explicitly.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.ApproxMPO-Tuple{ITensors.MPO, Any}","page":"API reference","title":"ReducedBasis.ApproxMPO","text":"ApproxMPO(mpo::MPO, opsum; <keyword arguments>)\n\nConstruct an ApproxMPO with default truncation settings.\n\nArguments\n\nmpo::MPO\nopsum::Sum{Scaled{ComplexF64,Prod{Op}}}\ncutoff::Float64=1e-9: relative cutoff for singular values.\nmaxdim::Int=1000: maximal bond dimension.\nmindim::Int=1: minimal bond dimension.\ntruncate::Bool=true: disables all truncate if set to false.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.DMRG","page":"API reference","title":"ReducedBasis.DMRG","text":"Solver type for the density matrix renormalization group (DMRG) as implemented in ITensors.dmrg.\n\nFields\n\nn_states::Int=1: see FullDiagonalization.\ntol_degeneracy::Float64=0.0: see FullDiagonalization.\nsweeps::Sweeps=default_sweeps(; cutoff_max=1e-9, bonddim_max=1000): set DMRG sweep settings via ITensors.Sweeps.\nobserver::Function=() -> DMRGObserver(; energy_tol=1e-9): set DMRG exit conditions. At each solve a new ITensors.AbstractObserver object is created.\nverbose::Bool=false: if true, prints info about DMRG solve.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.EigenDecomposition","page":"API reference","title":"ReducedBasis.EigenDecomposition","text":"Extension type for orthogonalization and compression using eigenvalue decomposition of the basis overlap matrix. See also extend.\n\nFields\n\ncutoff::Float64=1e-6: cutoff for minimal eigenvalue accuracy.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.ErrorEstimate","page":"API reference","title":"ReducedBasis.ErrorEstimate","text":"Super type of all error estimators.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.FullDiagonalization","page":"API reference","title":"ReducedBasis.FullDiagonalization","text":"Solver type for full diagonalization using LinearAlgebra.eigen.\n\nFields\n\nn_target::Int=1: the number of the targeted eigenvalue. If n_target=1, the degeneracy of the ground state is automatically determined up to tol_degeneracy. If tol_degeneracy=0, it determines the number of returned vectors per solve (also includes excited states).\ntol_degeneracy::Float64=0.0: tolerance for distinguishing two eigenvalues. If abs(λ₁ - λ₂) < tol_degeneracy, the eigenvalues are added to the same degenerate subspace.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.FullDiagonalization-Tuple{DMRG}","page":"API reference","title":"ReducedBasis.FullDiagonalization","text":"FullDiagonalization(dm::DMRG)\n\nConstruct FullDiagonalization with the same degeneracy tolerance as dm and fix n_target=1.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.FullDiagonalization-Tuple{LOBPCG}","page":"API reference","title":"ReducedBasis.FullDiagonalization","text":"FullDiagonalization(lobpcg::LOBPCG)\n\nConstruct the FullDiagonalization solver with degeneracy settings matching lobpcg.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.Greedy","page":"API reference","title":"ReducedBasis.Greedy","text":"Greedy reduced basis assembling strategy.\n\nFields\n\nestimator::ErrorEstimate: error estimate used in greedy condition. See also estimate_error\ntol::Float64=1e-3: tolerance for error estimate, below which the assembly is terminated.\nn_truth_max::Int=64: maximal number of truth solves to be taken up in the basis.\ninit_from_rb::Bool=true: if true, uses initial guesses from RB eigenvectors. See also interpolate.\nverbose::Bool=true: print information during assembly if true.\nexit_checks::Bool=true: if false, no exit checks will be performed and the assembly will run until tol or n_truth_max are reached.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.HamiltonianCache","page":"API reference","title":"ReducedBasis.HamiltonianCache","text":"Convenience type storing a Hamiltonian, its applications to vectors and its compressions.\n\nFields\n\nH::AffineDecomposition\nHΨ::Vector{V}\nΨHΨ::Vector{Matrix{T}}\nΨHHΨ::Matrix{Matrix{T}}\nh::AffineDecomposition\nh²::AffineDecomposition\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.HamiltonianCache-Tuple{AffineDecomposition, RBasis}","page":"API reference","title":"ReducedBasis.HamiltonianCache","text":"HamiltonianCache(H::AffineDecomposition, basis::RBasis)\n\nConstruct HamiltonianCache from a Hamiltonian computing all applications and compressions with an reduced basis.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.HamiltonianCache-Union{Tuple{T}, Tuple{V}, Tuple{HamiltonianCache, RBasis{V, T}}} where {V, T}","page":"API reference","title":"ReducedBasis.HamiltonianCache","text":"HamiltonianCache(hc::HamiltonianCache, basis::RBasis{V,T}) where {V,T}\n\nConstruct from previous HamiltonianCache, only computing necessary Hamiltonian applications and inner products.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.InfoCollector","page":"API reference","title":"ReducedBasis.InfoCollector","text":"Carries a Dict of Vectors which contain information from greedy assembly iterations.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.InfoCollector-Tuple{Any}","page":"API reference","title":"ReducedBasis.InfoCollector","text":"(collector::InfoCollector)(info)\n\nPush iteration information into InfoCollector and return info object, containing the InfoCollector itself.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.InfoCollector-Tuple{Vararg{Symbol}}","page":"API reference","title":"ReducedBasis.InfoCollector","text":"InfoCollector(fields::Symbol...)\n\nConstruct InfoCollector from fields that are contained in the info iteration state object. Possible fields to select from are:\n\niteration: number of iteration at which the information was obtained.\nerr_grid: error estimate on all parameter points of the training grid.\nerr_max: maximal error estimate on the grid.\nλ_grid: RB energies on all training grid points.\nμ: parameter point at which truth solve has been performed.\nbasis: RBasis at the current iteration.\nh_cache: HamiltonianCache at the current iteration.\nextend_info: info that is specific to the chosen extension procedure.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.LOBPCG","page":"API reference","title":"ReducedBasis.LOBPCG","text":"Solver type for the Locally Optimal Block Preconditioned Conjugate Gradient (LOBPCG). Currently uses the DFTK lobpcg_hyper implementation.\n\nFields\n\nn_target::Int=1: see FullDiagonalization.\ntol_degeneracy::Float64=0.0: see FullDiagonalization.\ntol::Float64=1e-9: tolerance for residual norms.\nmaxiter::Int=300: maximal number of LOBPCG iterations.\nn_ep_extra::Int=4: number of extra eigenpairs that are kept to improve convergence.\nshift::Float64=-100: eigenvalue shift.\nverbose::Bool=false: if true, print convergence messages.\ndense_fallback::Bool=true: if false, also non-converged states will be accepted. Otherwise LinearAlgebra.eigen is used for non-converged iterations.\nmaxdiagonal::Int=400\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.NoCompress","page":"API reference","title":"ReducedBasis.NoCompress","text":"Extension type for no orthonormalization or compression. See also extend.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.POD","page":"API reference","title":"ReducedBasis.POD","text":"Proper orthogonal decomposition assembly strategy.\n\nFields\n\nn_vectors::Int: number of retained singular vectors of the snapshot matrix in the returned basis.\nverbose::Bool=true: shows the truth solve progress if true.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.QRCompress","page":"API reference","title":"ReducedBasis.QRCompress","text":"Extension type for QR orthonormalization and compression. See extend for details.\n\nFields\n\ntol::Float64: tolerance for compressing insignificant basis snapshots.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.RBasis","page":"API reference","title":"ReducedBasis.RBasis","text":"Central type containing snapshots and associated objects that make a reduced basis.\n\nThe snapshot vectors are contained in snapshots::AbstractVector{V} where the snapshots are of type V. Here a \"snapshot\" refers to all vectors that were obtained from a solve at a specific parameter point. For greedy-generated bases, each element in snapshots has a parameter point in parameter::Vector{P}, i.e. for snapshots bmPsi(bmmu_i) = (Psi_1(bmmu_i)dotsPsi_m(bmmu_i)) of multiplicity m the parameter point bmmu is contained m times. However, for general basis-assembly strategies this one-to-one correspondence might not be true, e.g. for POD where snapshots contains singular vectors based on all truth solves.\n\nTreated as a matrix, the reduced basis B = Upsilon V is made up of the snapshot vectors as column vectors in Upsilon and vector coefficients V. The latter are stored in vectors. In the simple case of B = Upsilon, one sets vectors=I.\n\nSince the matrix B^dagger B = V^dagger Upsilon^dagger Upsilon V is frequently needed, both the snapshot_overlaps Upsilon^dagger Upsilon and the metric B^dagger B are stored with generic floating-point type T.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.RegularGrid","page":"API reference","title":"ReducedBasis.RegularGrid","text":"Stores equidistant grid of parameter points as well as its interval ranges.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.RegularGrid-Tuple{Vararg{StepRangeLen}}","page":"API reference","title":"ReducedBasis.RegularGrid","text":"RegularGrid(ranges::StepRangeLen...)\n\nConstruct a D-dimensional RegularGrid from D ranges.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.Residual","page":"API reference","title":"ReducedBasis.Residual","text":"Estimator type for the residual mathrmRes(bmmu) = lVert H(bmmu) B varphi(bmmu) - lambda B varphi(bmmu) rVert.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.:*-Tuple{ApproxMPO, ITensors.MPS}","page":"API reference","title":"Base.:*","text":"*(o::ApproxMPO, mps::MPS)\n\nApply o.mpo to mps using the truncation arguments contained in o.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.truncate-Tuple{AffineDecomposition, RBasis}","page":"API reference","title":"Base.truncate","text":"Base.truncate(ad_raw::AffineDecomposition, basis_trunc::RBasis)\nBase.truncate(ad::AffineDecomposition,\n              basis_trunc::RBasis{V,T,P,<:UniformScaling}) where {V,T<:Number,P}\n\nTruncate an AffineDecomposition.\n\nFor general RBasis, the \"raw\" AffineDecomposition has to be provided, where ad_raw.terms are the matrix elements Psi_i^dagger O_r Psi_j. The returned decomposition then contains the fully compressed transformed terms, i.e. B^dagger O_r B using the truncated basis.\n\nIn case a basis is provided that has trivial vectors=I, the truncation is performed naively on the fully compressed terms.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.truncate-Tuple{HamiltonianCache, RBasis}","page":"API reference","title":"Base.truncate","text":"Base.truncate(hc::HamiltonianCache, basis_trunc::RBasis)\n\nTruncate a [HamiltonianCache] according to an already truncated basis.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.truncate-Tuple{RBasis, Int64}","page":"API reference","title":"Base.truncate","text":"Base.truncate(basis::RBasis, n_truth::Int)\n\nTruncate the RBasis to n_truth snapshots.\n\nNote that n_truth does not amount to the dimension of the truncated basis, but the number of truth solves included in the basis, which can feature degenerate snapshots.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.assemble-Tuple{AffineDecomposition, Any, POD, Any}","page":"API reference","title":"ReducedBasis.assemble","text":"assemble(H::AffineDecomposition, grid, pod::POD, solver_truth)\n\nAssemble basis using POD.\n\nOnly ED solvers such as FullDiagonalization and LOBPCG are supported. The generated RBasis will contain pod.n_vectors singular vectors in snapshots and all grid points in parameters. This means that parameters and snapshots generally have different lengths.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.assemble-Tuple{NamedTuple, AffineDecomposition, Any, Greedy, Any, Any}","page":"API reference","title":"ReducedBasis.assemble","text":"assemble(H, grid, greedy, solver_truth, compressalg; <keyword arguments>)\nassemble(info, H, grid, greedy, solver_truth, compressalg; <keyword arguments>)\n\nAssemble an RBasis using the greedy strategy and any truth solving method.\n\nIf info is not provided, start a greedy assembly from scratch.\n\nArguments\n\ninfo::NamedTuple: iteration state from a previous simulation that will be resumed.\nH::AffineDecomposition: Hamiltonian for which a reduced basis is assembled.\ngrid: parameter grid that defines the parameter domain.\ngreedy::Greedy: greedy strategy containing assembly parameters. See also Greedy.\nsolver_truth: solving method for obtaining ground state snapshots.\ncompressalg: compression method for orthogonalization, etc. See also extend.\nsolver_online=FullDiagonalization(solver_truth): solving method that is used for the RB generalized eigenvalue problem.\ncallback=print_callback: callback function that operates on the iteration state during assembly. It is possible to chain multiple callback functions using ∘.\nμ_start=grid[1]: parameter point of the starting iteration, if no info is provided.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.bounds-Union{Tuple{RegularGrid{D}}, Tuple{D}} where D","page":"API reference","title":"ReducedBasis.bounds","text":"bounds(grid::RegularGrid{D}) where {D}\n\nReturn SVector of grid boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.compress-Tuple{AbstractMatrix, AbstractVector{<:AbstractVector}}","page":"API reference","title":"ReducedBasis.compress","text":"compress(M::AbstractMatrix, snapshots::AbstractVector{<:AbstractVector})\n\nCompress term using matrix multiplications.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.compress-Tuple{AffineDecomposition, RBasis}","page":"API reference","title":"ReducedBasis.compress","text":"compress(ad::AffineDecomposition, basis::RBasis)\n\nPerform the compression of an AffineDecomposition corresponding to o = B^dagger O B.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.compress-Tuple{AffineDecomposition{<:Matrix}, RBasis}","page":"API reference","title":"ReducedBasis.compress","text":"compress(ad::AffineDecomposition{<:Matrix,<:Function},\n         basis::RBasis; symmetric_terms=false)\n\nPerform compression for an AffineDecomposition with terms with two indices (double-sum observables), including an option to exploit the possible symmetry of terms O_rr = O_rr, such that only the necessary compressions are computed.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.compress-Tuple{Any, AbstractVector}","page":"API reference","title":"ReducedBasis.compress","text":"compress(op, snapshots::AbstractVector)\n\nCompress one term of an AffineDecomposition ApproxMPO type.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.default_sweeps-Tuple{}","page":"API reference","title":"ReducedBasis.default_sweeps","text":"default_sweeps(; cutoff_max=1e-9, bonddim_max=1000)\n\nReturn default ITensors.Sweeps object for DMRG solves, containing decreasing noise and increasing maximal bond dimension ramps.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.dimension-Tuple{RBasis}","page":"API reference","title":"ReducedBasis.dimension","text":"dimension(basis::RBasis)\n\nReturn the basis dimension dim B.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.estimate_error-Tuple{Residual, Any, HamiltonianCache, RBasis, Any}","page":"API reference","title":"ReducedBasis.estimate_error","text":"estimate_error(::Residual, μ, h_cache::HamiltonianCache, basis::RBasis, sol_rb)\n\nEstimate error of reduced basis using the Residual estimator.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.extend-Tuple{RBasis, AbstractVector, Any, EigenDecomposition}","page":"API reference","title":"ReducedBasis.extend","text":"extend(basis::RBasis, new_snapshot::AbstractVector, μ, ed::EigenDecomposition)\n\nExtend the reduced basis by orthonormalizing and compressing via eigenvalue decomposition.\n\nThe overlap matrix S in basis.snapshot_overlaps is eigenvalue decomposed S = U^dagger Lambda U and orthonormalized by computing the vector coefficients V = U Lambda^-12. Modes with an relative squared eigenvalue error smaller than ed.cutoff are dropped.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.extend-Tuple{RBasis, AbstractVector, Any, NoCompress}","page":"API reference","title":"ReducedBasis.extend","text":"extend(basis::RBasis, new_snapshot, μ, ::NoCompress)\n\nExtend the reduced basis by one snapshot without any orthogonalization or compression procedure.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.extend-Tuple{RBasis, AbstractVector, Any, QRCompress}","page":"API reference","title":"ReducedBasis.extend","text":"extend(basis::RBasis, new_snapshot::AbstractVector, μ, qrcomp::QRCompress)\n\nExtend using QR orthonormalization and compression.\n\nThe orthonormalization is performed by QR decomposing the orthogonal projection bmPsi(bmmu_n+1) - B_n^dagger B_n^dagger B_n^-1 B_n bmPsi(bmmu_n) and appending Q to snapshots. Modes that have an R column maximum falling below the qrcomp.tol tolerance are dropped.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.extend_overlaps-Tuple{Matrix, Vector, Vector}","page":"API reference","title":"ReducedBasis.extend_overlaps","text":"extend_overlaps(old_overlaps::Matrix, old_snapshots::Vector, new_snapshot::Vector)\n\nExtend an overlap matrix by one snapshot, where only the necessary dot products are computed.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.in_bounds-Tuple{Any, RegularGrid}","page":"API reference","title":"ReducedBasis.in_bounds","text":"in_bounds(μ, grid::RegularGrid)\n\nCheck whether a given parameter point μ is in the convex hull of the grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.interpolate-Tuple{RBasis, AffineDecomposition, Any, Any, Any}","page":"API reference","title":"ReducedBasis.interpolate","text":"interpolate(basis::RBasis, h::AffineDecomposition, μ, _, solver_online)\n\nCompute Hilbert-space-dimensional ground state vector at parameter point μ from the reduced basis using bmPhi(bmmu) = B bmvarphi(bmmu).\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.interpolate-Tuple{RBasis{ITensors.MPS}, AffineDecomposition, Any, DMRG, Any}","page":"API reference","title":"ReducedBasis.interpolate","text":"interpolate(basis::RBasis{MPS}, h::AffineDecomposition, μ, dm::DMRG, solver_online)\n\nCompute ground state MPS at μ from the reduced basis by MPS addition in  Phi(bmmu) rangle = sum_k=1^dim B V varphi(bmmu_k)_k  Psi(bmmu_k) rangle.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.multiplicity-Tuple{RBasis}","page":"API reference","title":"ReducedBasis.multiplicity","text":"multiplicity(basis::RBasis)\n\nReturn the multiplicity of each truth solve.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.n_truthsolve-Tuple{RBasis}","page":"API reference","title":"ReducedBasis.n_truthsolve","text":"n_truthsolve(basis::RBasis)\n\nReturn the number of truth solves (snapshots) contained in the basis.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.overlap_matrix-Tuple{Vector, Vector}","page":"API reference","title":"ReducedBasis.overlap_matrix","text":"overlap_matrix(v1::Vector, v2::Vector)\n\nCompute the overlap matrix of two sets of vector-like objects v1 and v2.\n\nThe computed matrix elements are the dot products dot(v1[i], v2[j]). Correspondingly, the elements of v1 and v2 must support a LinearAlgebra.dot method. In the case where v1 = v2, the Gram matrix is computed.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.print_callback-Tuple{Any}","page":"API reference","title":"ReducedBasis.print_callback","text":"print_callback(info)\n\nPrint diagnostic information in each assembly iterations.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.reconstruct-Tuple{ITensors.MPS}","page":"API reference","title":"ReducedBasis.reconstruct","text":"reconstruct(mps::MPS)\n\nExplicitly compute Hilbert-space-dimensional vector by reconstructing all MPS coefficients.\n\nwarning: Memory restrictions\nThe number of MPS coefficients grows exponentially with system size, such that the explicit reconstruction is only possible for small systems.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.shift-Union{Tuple{N}, Tuple{D}, Tuple{RegularGrid{D, N}, Any}} where {D, N}","page":"API reference","title":"ReducedBasis.shift","text":"shift(grid::RegularGrid{D,N}, μ_shift; stay_in_bounds=false) where {D,N}\n\nShift a regular grid by a shift vector μ_shift. If stay_in_bounds=true, the shifted grid will stay in the convex hull of the unshifted grid. Note that the shift vector elements cannot be larger than the grid.ranges steps.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.solve-Tuple{AffineDecomposition, Any, Any, FullDiagonalization}","page":"API reference","title":"ReducedBasis.solve","text":"solve(H::AffineDecomposition, μ, Ψ₀, fd::FullDiagonalization)\n\nSolve Hamiltonian for lowest eigenvalues and eigenvectors at parameter point μ using  FullDiagonalization.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.solve-Tuple{AffineDecomposition, Any, Union{Nothing, Matrix}, LOBPCG}","page":"API reference","title":"ReducedBasis.solve","text":"solve(H::AffineDecomposition, μ, Ψ₀::Union{Matrix,Nothing}, lobpcg::LOBPCG)\n\nSolve using LOBPCG. If nothing is provided as an initial guess, an orthogonal random matrix will be used with lobpcg.n_target + lobpcg.n_ep_extra column vectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.solve-Tuple{AffineDecomposition, Any, Union{Nothing, Vector{ITensors.MPS}}, DMRG}","page":"API reference","title":"ReducedBasis.solve","text":"solve(H::AffineDecomposition, μ, Ψ₀::Union{Vector{MPS},Nothing}, dm::DMRG)\n\nSolve using DMRG. When nothing is provided as an initial guess, dm.n_states random MPS are used.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.solve-Tuple{AffineDecomposition, Matrix, Any, FullDiagonalization}","page":"API reference","title":"ReducedBasis.solve","text":"solve(h::AffineDecomposition, b::Matrix, μ, fd::FullDiagonalization)\n\nSolve the generalized eigenvalue problem h(bmmu) varphi(bmmu) = lambda(bmmu) b varphi(bmmu) at parameter point μ using FullDiagonalization.\n\n\n\n\n\n","category":"method"},{"location":"examples/multi_ad/#Affine-decompositions-with-multi-indices-and-additional-parameters","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"","category":"section"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"In this example, we want to explore the capabilities of the central AffineDecomposition type. To advance the previous examples where we covered the magnetization — a very simple observable that consists of only one affine term and a parameter-independent coefficient — we now turn to observables where the indices are multi-indices r = (r_1 dots r_d) and the coefficients can depend on additional parameters p, aside from the bmmu parameter points that are present in the Hamiltonian:","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"O(bmmu p) = sum_q=1^Q alpha_q(bmmu p) O_q","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"To stay within the realm of spin physics, we will consider the so-called spin structure factor","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"mathcalS(k) = frac1L sum_rr=1^L e^-i (r - r) k S^z_r S^z_rquad\nalpha_rr(k) = frace^-i (r - r) kL quad\nO_rr =  S^z_r S^z_r","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"with a wavevector parameter k, to discuss the implementation of a more complicated observable.","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"using LinearAlgebra, SparseArrays, Plots, ReducedBasis # hide\n\nσx = sparse([0.0 1.0; 1.0 0.0]) # hide\nσy = sparse([0.0 -im; im 0.0]) # hide\nσz = sparse([1.0 0.0; 0.0 -1.0]) # hide\n\nfunction to_global(op::M, L::Int, i::Int) where {M<:AbstractMatrix} # hide\n    d = size(op, 1) # hide\n\n    if i == 1 # hide\n        return kron(op, M(I, d^(L - 1), d^(L - 1))) # hide\n    elseif i == L # hide\n        return kron(M(I, d^(L - 1), d^(L - 1)), op) # hide\n    else # hide\n        return kron(kron(M(I, d^(i - 1), d^(i - 1)), op), M(I, d^(L - i), d^(L - i))) # hide\n    end # hide\nend # hide\n\nfunction xxz_chain(L) # hide\n    H1 = 0.25 * sum([to_global(σx, L, i) * to_global(σx, L, i + 1) + # hide\n                     to_global(σy, L, i) * to_global(σy, L, i + 1) for i in 1:(L-1)]) # hide\n    H2 = 0.25 * sum([to_global(σz, L, i) * to_global(σz, L, i + 1) for i in 1:(L-1)]) # hide\n    H3 = 0.5  * sum([to_global(σz, L, i) for i in 1:L]) # hide\n    coefficient_map = μ -> [1.0, μ[1], -μ[2]] # hide\n    AffineDecomposition([H1, H2, H3], coefficient_map) # hide\nend # hide\n\nL = 6 # hide\nH = xxz_chain(L) # hide\nΔ = range(-1.0, 2.5; length=40) # hide\nhJ = range(0.0, 3.5; length=40) # hide\ngrid_train = RegularGrid(Δ, hJ) # hide\ngreedy = Greedy(; estimator=Residual(), tol=1e-3, init_from_rb=true) # hide\nlobpcg = LOBPCG(; n_target=1, tol_degeneracy=1e-4, tol=1e-9) # hide\nqrcomp = QRCompress(; tol=1e-9) # hide\n\ninfo = assemble(H, grid_train, greedy, lobpcg, qrcomp) # hide\nbasis = info.basis; h = info.h_cache.h; # hide\n\nΔ_online = range(first(Δ), last(Δ); length=100) # hide\nhJ_online = range(first(hJ), last(hJ); length=100) # hide\ngrid_online = RegularGrid(Δ_online, hJ_online) # hide\nfulldiag = FullDiagonalization(lobpcg) # hide","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"So let us continue the first example where we have generated an L=6 XXZ surrogate basis with a reduced Hamiltonian h using an exact diagonalization solver. Now the task is to implement the double-sum in mathcalS, as well as the k-dependency in the coefficients. The double-sum can be encoded by putting all S^z_r S^z_r combinations into a L times L matrix:","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"terms = map(idx -> to_global(σz, L, first(idx.I)) * to_global(σz, L, last(idx.I)),\n            CartesianIndices((1:L, 1:L)))","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"Correspondingly, the coefficient function now has to map one k value to a matrix of coefficients of the same size as the terms matrix:","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"coefficient_map = k -> map(idx -> cis(-(first(idx.I) - last(idx.I)) * k) / L,\n                           CartesianIndices((1:L, 1:L)))","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"One feature of the structure factor that also shows up in many other affine decompositions with double-sums is that the term indices commute, i.e. O_rr = O_rr. In that case, only the upper triangular matrix has to be computed since B^dagger O_rr B = B^dagger O_rr B are the same in the compressed affine decomposition. So let's create the AffineDecomposition and compress, exploiting this symmetry using the symmetric_terms keyword argument:","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"SFspin = AffineDecomposition(terms, coefficient_map)\nsfspin, _ = compress(SFspin, basis; symmetric_terms=true)","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"In the online evaluation of the structure factor, we then need to define some wavevector values and compute the structure factor at each of them. With the grid_online from before, this reads:","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"wavevectors = [0.0, π/4, π/2, π]\nsf = [zeros(size(grid_online)) for _ in 1:length(wavevectors)]\nfor (idx, μ) in pairs(grid_online)\n    _, φ_rb = solve(h, basis.metric, μ, fulldiag)\n    for (i, k) in enumerate(wavevectors)\n        sf[i][idx] = sum(eachcol(φ_rb)) do u\n            real(dot(u, sfspin(k), u))\n        end / size(φ_rb, 2)\n    end\nend","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"Here we again see the convenience of measuring observables in the online stage; adding more wavevector values does not significantly increase the computational cost, since it corresponds to a mere reevaluation of the coefficient functions and small vector-matrix products. Finally, let us see how the structure factor behaves for the different wavevector values:","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"kwargs = (; xlabel=raw\"$\\Delta$\", ylabel=raw\"$h/J$\", colorbar=true, leg=false) # hide\nhms = []\nfor (i, q) in enumerate(wavevectors)\n    push!(hms, heatmap(grid_online.ranges[1], grid_online.ranges[2], sf[i]'; \n                       title=\"\\$k = $(round(q/π; digits=3))\\\\pi\\$\", kwargs...))\nend\nplot(hms...)","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"It can be nicely seen that the spin structure factor indicates the ferromagnetic phase at k=0 and then moves through the magnetization plateaus until it reaches the antiferromagnetic plateau at k=pi.","category":"page"},{"location":"examples/xxz_ed/#The-reduced-basis-workflow","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"","category":"section"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"In this first example we want to provide an introduction to the reduced basis framework as applied to quantum spin systems. We want to see, from start to finish, how to set up a physical model, how to generate a surrogate basis and how to finally compute observable quantities. For that purpose, we cover the three basic steps of the reduced basis workflow:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Model setup: We first need to initialize the model Hamiltonian and the associated physical parameters.\nOffline phase: An assembly strategy and a truth solving method is chosen, with which we generate the reduced basis surrogate and we prepare observables for later measurement.\nOnline phase: Using the surrogate, we measure observables with reduced computational cost.","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Let us see, how to perform these steps using ReducedBasis.jl. As a first application, we will explore a canonical model from quantum spin physics, the one-dimensional spin-1/2 XXZ chain","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"H = sum_i=1^L-1 big S_i^x S_i+1^x + S_i^y S_i+1^y + Delta S_i^z S_i+1^z big - frachJ sum_i=1^L S_i^z ","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"To assemble the basis, a greedy algorithm will be used that tries to select as few snapshots as possible to generate a good surrogate. And to keep things simple, we will utilize exact diagonalization techniques to perform the eigenvalue solves to obtain snapshots at the desired parameter points. This means, H will be represented by a (sparse) matrix and the snapshots by vectors of Hilbert space dimension. Alternatively, one could e.g. provide H and its ground states in a tensor-based format allowing for low-rank approximations, which is reserved for a later example.","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"note: Simulation parameters\nIn the following we choose the simulation parameters in such a way to keep the computational load small. We do this to be able to automatically run all example code during documentation compilation. As a result, the physical results have artifacts that are characteristic for small systems, i.e. finite-size effects.","category":"page"},{"location":"examples/xxz_ed/#Model-setup","page":"The reduced basis workflow","title":"Model setup","text":"","category":"section"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Let us first set up the parametrized Hamiltonian matrix. In this specific example, we will need some utility functions to generate many-body spin Hamiltonians but in other applications, possibly not connected to physics, the Hamiltonian setup will of course differ. However, all parametrized Hamiltonians will need to be cast into the form of an affine decomposition","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"H (bmmu) = sum_q=1^Q theta_q(bmmu) H_q ","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"The corresponding type in ReducedBasis is the AffineDecomposition which, as we will see, will account for both Hamiltonians and other observables that one would want to measure.","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Now coming to the XXZ chain, we want to implement the parametrized Hamiltonian matrix, for which we first need a way to create global many-body operators","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"S_i^gamma = (otimes^i-1 I) otimes frac12sigma^gamma otimes (otimes^N-i I) ","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"which in this case are S=12 operators featuring the Pauli matrices sigma^gamma. So, let us first define the Pauli matrices as sparse matrices","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"using LinearAlgebra\nusing SparseArrays\nusing Plots\nusing ReducedBasis\n\nσx = sparse([0.0 1.0; 1.0 0.0])\nσy = sparse([0.0 -im; im 0.0])\nσz = sparse([1.0 0.0; 0.0 -1.0])","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"and create a function to make single-site operators global operators at site i for a many-body system of length L:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"function to_global(op::M, L::Int, i::Int) where {M<:AbstractMatrix}\n    d = size(op, 1)\n\n    if i == 1\n        return kron(op, M(I, d^(L - 1), d^(L - 1)))\n    elseif i == L\n        return kron(M(I, d^(L - 1), d^(L - 1)), op)\n    else\n        return kron(kron(M(I, d^(i - 1), d^(i - 1)), op), M(I, d^(L - i), d^(L - i)))\n    end\nend","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"To be able to create an AffineDecomposition, we first need to identify the terms H_q and the coefficient functions theta_q(bmmu). In our specific case, we can identify the parameter vector bmmu = (1 Delta hJ) and the associated coefficient function as bmtheta(bmmu) = (1 mu_1 -mu_2). Hence we arrive at the following Hamiltonian implementation:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"function xxz_chain(L)\n    H1 = 0.25 * sum([to_global(σx, L, i) * to_global(σx, L, i + 1) +\n                     to_global(σy, L, i) * to_global(σy, L, i + 1) for i in 1:(L-1)])\n    H2 = 0.25 * sum([to_global(σz, L, i) * to_global(σz, L, i + 1) for i in 1:(L-1)])\n    H3 = 0.5  * sum([to_global(σz, L, i) for i in 1:L])\n    coefficient_map = μ -> [1.0, μ[1], -μ[2]]\n    AffineDecomposition([H1, H2, H3], coefficient_map)\nend","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Using these functions, we initialize a small system of length L=6 with a matrix dimension of 2^6 = 64:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"L = 6\nH = xxz_chain(L)","category":"page"},{"location":"examples/xxz_ed/#Offline-phase","page":"The reduced basis workflow","title":"Offline phase","text":"","category":"section"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Now we can proceed by assembling the reduced basis. To that end we first choose a solver to find the lowest eigenvectors of H, for which in this case we use the LOBPCG solver. Since the XXZ model as defined above harbors degenerate ground states at some parameter points, we need to choose the right solver settings to account for that. To obtain only the ground state subspace, we set n_target=1 and different eigenvalues are then distinguished up some tolerance tol_degeneracy. The general solver accuracy is set via the tol keyword argument:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"lobpcg = LOBPCG(; n_target=1, tol_degeneracy=1e-4, tol=1e-9)","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Next, we need to restrict our surrogate to a certain domain in the (Delta hJ) parameter space and define a discrete grid of points on that domain. This is achieved, for example, by defining a 2-dimensional regular grid of parameter points using RegularGrid:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Δ = range(-1.0, 2.5; length=40)\nhJ = range(0.0, 3.5; length=40)\ngrid_train = RegularGrid(Δ, hJ)","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"For reasons of numerical stability, it is important orthogonalize the reduced basis during assembly (or use similar methods to keep the problem well-conditioned). Hence there are different protocols to extend a reduced basis by a new snapshot. An numerically efficient way to realize this is to use QR decomposition methods as implemented in QRCompress. Note that we choose a tolerance tol to discard snapshot vectors that do not significantly contribute to the basis:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"qrcomp = QRCompress(; tol=1e-9)","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"We lastly need to set the parameters for the greedy basis assembly by creating a Greedy object. This includes choosing an error estimate, as well as an error tolerance below which we stop the basis assembly:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"greedy = Greedy(; estimator=Residual(), tol=1e-3, init_from_rb=true)","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"With that, we gathered all elements to be able generate the reduced basis:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"info = assemble(H, grid_train, greedy, lobpcg, qrcomp)\nbasis = info.basis; h = info.h_cache.h;","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"To finish up the offline phase, we want to define an observable, again as an AffineDecomposition and then compress it, to be able to measure it efficiently in the online stage. We will use the magnetization M = 2L^-1 sum_i=1^L S_i^z that serves as a so-called order parameter to distinguish different phases of the system in the parameter space. Conveniently, the magnetization already is contained in the third term of H:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"M = AffineDecomposition([H.terms[3]], μ -> [2 / L])\nm, _ = compress(M, basis)","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Note that the compression again produces an AffineDecomposition which now contains only the low-dimensional matrices that operate in reduced basis space. In addition to the compressed observable, compress also returns a second decomposition for analysis purposes, which we will not cover in this example and hence did not assign. Since the coefficient 2L^-1 is actually parameter-independent, we can just construct m at some parameter point to obtain the reduced magnetization matrix for all parameters:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"m_reduced = m([])","category":"page"},{"location":"examples/xxz_ed/#Online-phase","page":"The reduced basis workflow","title":"Online phase","text":"","category":"section"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Having assembled a reduced basis surrogate, we now want to scan the parameter domain by measuring observables, in particular the magnetization from above. Fortunately, we have finished all Hilbert-space-dimension dependent steps and only operate in the low dimensional reduced basis space. This allows us to now compute observables on a much finer grid:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Δ_online = range(first(Δ), last(Δ); length=100)\nhJ_online = range(first(hJ), last(hJ); length=100)\ngrid_online = RegularGrid(Δ_online, hJ_online)","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Instead of solving for the ground states of H, we solve for the lowest eigenvectors of the reduced Hamiltonian in the online phase. Again, we need a solver, which in this case is FullDiagonalization, i.e. a wrapper around LinearAlgebra.eigen. To use degeneracy settings that match lobpcg from above, we can use the matching constructor:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"fulldiag = FullDiagonalization(lobpcg)","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"To compute expectation values on all online grid points — which we mean by \"scanning\" the parameter domain — it is convenient to use a map:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"magnetization = map(grid_online) do μ\n    _, φ_rb = solve(h, basis.metric, μ, fulldiag)\n    sum(u -> abs(dot(u, m_reduced, u)), eachcol(φ_rb)) / size(φ_rb, 2)\nend","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Finally, we can take a look at the results. Note that, to plot a magnetization heatmap, we need to transpose the magnetization matrix, in order to use the rows as the x-axis. In addition to the magnetization, let us also plot the parameter points at which we performed truth solves in the offline stage:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"hm = heatmap(grid_online.ranges[1], grid_online.ranges[2], magnetization';\n             xlabel=raw\"$\\Delta$\", ylabel=raw\"$h/J$\", title=\"magnetization\",\n             colorbar=true, clims=(0.0, 1.0), leg=false)\nplot!(hm, grid_online.ranges[1], x -> 1 + x; lw=2, ls=:dash, legend=false, color=:green)\nparams = unique(basis.parameters)\nscatter!(hm, [μ[1] for μ in params], [μ[2] for μ in params];\n         markershape=:xcross, color=:springgreen, ms=3.0, msw=2.0)","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"As expected from theory, we observe L2+1 discrete magnetization plateaus, as well as a ferromagnetic (M=1) and an antiferromagnetic phase (M=0) in the ground state phase diagram.","category":"page"},{"location":"examples/xxz_pod/#Basis-assembly-using-Proper-Orthogonal-Decomposition","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"","category":"section"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"In the last examples we have seen that we can customize the snapshot solvers as well as the compression methods during reduced basis assembly. What we want to demonstrate in this example is that we can also use different strategies for basis assembly altogether. In particular, we will show how to use the Proper Orthogonal Decomposition (POD) technique in the offline stage.","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"using LinearAlgebra, SparseArrays, Plots, ReducedBasis # hide\n\nσx = sparse([0.0 1.0; 1.0 0.0]) # hide\nσy = sparse([0.0 -im; im 0.0]) # hide\nσz = sparse([1.0 0.0; 0.0 -1.0]) # hide\n\nfunction to_global(op::M, L::Int, i::Int) where {M<:AbstractMatrix} # hide\n    d = size(op, 1) # hide\n\n    if i == 1 # hide\n        return kron(op, M(I, d^(L - 1), d^(L - 1))) # hide\n    elseif i == L # hide\n        return kron(M(I, d^(L - 1), d^(L - 1)), op) # hide\n    else # hide\n        return kron(kron(M(I, d^(i - 1), d^(i - 1)), op), M(I, d^(L - i), d^(L - i))) # hide\n    end # hide\nend # hide\n\nfunction xxz_chain(L) # hide\n    H1 = 0.25 * sum([to_global(σx, L, i) * to_global(σx, L, i + 1) + # hide\n                     to_global(σy, L, i) * to_global(σy, L, i + 1) for i in 1:(L-1)]) # hide\n    H2 = 0.25 * sum([to_global(σz, L, i) * to_global(σz, L, i + 1) for i in 1:(L-1)]) # hide\n    H3 = 0.5  * sum([to_global(σz, L, i) for i in 1:L]) # hide\n    coefficient_map = μ -> [1.0, μ[1], -μ[2]] # hide\n    AffineDecomposition([H1, H2, H3], coefficient_map) # hide\nend # hide","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"The conceptual difference between POD and the greedy assembly strategy is that with POD, a truth solve is performed at all parameter points in the selected grid, followed by a singular value decomposition of the snapshot matrix. In this way, we obtain an orthogonal basis by using the singular vectors as our reduced basis. While this procedure is less complex than the greedy strategy, it comes with the significantly increased cost of having to solve snapshots at all grid points. Nonetheless, it can be useful to e.g. obtain a reference reduced basis and to compare against a greedy basis.","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"So let us stay with the example of the XXZ spin chain and initialize the Hamiltonian as before (using the functions defined in the first example) and choose a grid as well as a solver method:","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"L = 6\nH = xxz_chain(L)\n\nΔ = range(-1.0, 2.5; length=20)\nhJ = range(0.0, 3.5; length=20)\ngrid_train = RegularGrid(Δ, hJ)\n\nlobpcg = LOBPCG(; n_target=1, tol_degeneracy=1e-4, tol=1e-9)","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"Notice that we now use a coarser 20 × 20 grid since we perform truth solves on all parameter points and want to keep the computational effort low. Moreover, we are restricted to exact diagonalization solvers, since we need to explicitly construct the snapshot matrix in order to be able to perform an SVD on it. To assemble using POD, we create a POD object where we specify the number of retained columns, i.e. singular vectors of the snapshot matrix:","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"pod = POD(; n_vectors=24)","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"We then call assemble using our parameters, including pod, which selects the POD assembly method:","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"info = assemble(H, grid_train, pod, lobpcg)","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"Since we do not compute any Hamiltonian compressions during POD, we need to compute them afterwards using the HamiltonianCache constructor (recall that h is needed in the online stage):","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"h_cache = HamiltonianCache(H, info.basis)\nbasis = info.basis; h = h_cache.h;","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"M = AffineDecomposition([H.terms[3]], μ -> [2 / L]) # hide\nm, _ = compress(M, basis) # hide\nm_reduced = m([1]) # hide\n\nΔ_online = range(first(Δ), last(Δ); length=100) # hide\nhJ_online = range(first(hJ), last(hJ); length=100) # hide\ngrid_online = RegularGrid(Δ_online, hJ_online) # hide\nfulldiag = FullDiagonalization(lobpcg) # hide\nmagnetization = map(grid_online) do μ # hide\n    _, φ_rb = solve(h, basis.metric, μ, fulldiag) # hide\n    sum(eachcol(φ_rb)) do u # hide\n        abs(dot(u, m_reduced, u)) # hide\n    end / size(φ_rb, 2) # hide\nend # hide","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"Again, we arrive at the online phase which is performed analogously to the first example. We hence skip directly to the end result:","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"hm = heatmap(grid_online.ranges[1], grid_online.ranges[2], magnetization';\n             xlabel=raw\"$\\Delta$\", ylabel=raw\"$h/J$\", title=\"magnetization\",\n             colorbar=true, clims=(0.0, 1.0), leg=false)\nplot!(hm, grid_online.ranges[1], x -> 1 + x; lw=2, ls=:dash, legend=false, color=:green)","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"The magnetization phase diagram is correctly reproduced, however this time without the parameter point markers being plotted. This is due to the fact that all points in grid_train have been solved and incorporated into the reduced basis according to the POD procedure. The number of retained singular vectors therefore does not correspond directly to snapshots at certain parameter points but to linear combinations of them.","category":"page"},{"location":"examples/xxz_dmrg/#Greedy-basis-assembly-using-DMRG","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"","category":"section"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"As a follow-up example, we now want to showcase how to compute a reduced basis by means of the density matrix renormalization group (DMRG). To that end, we utilize the ITensors.jl package which, among other things, efficiently implements DMRG. We will see that, while we need to adjust the way we set up the model Hamiltonian as well as our solver, most steps stay the same. Again, we treat the one-dimensional S=12 XXZ model from the previous example.","category":"page"},{"location":"examples/xxz_dmrg/#Hamiltonians-as-MPOs","page":"Greedy basis assembly using DMRG","title":"Hamiltonians as MPOs","text":"","category":"section"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"Let us begin by building the XXZ Hamiltonian. Instead of constructing explicit matrices from Kronecker products as we did before, we now use a tensor format called matrix product operators (MPOs) to represent the Hamiltonian. For that purpose, we first import","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"using LinearAlgebra\nusing ITensors\nusing Plots\nusing ReducedBasis","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"now featuring ITensors. To build the Hamiltonian terms as MPOs, we make use of the ITensors.OpSum() object that automatically produces an MPO from a string of operators. The affine MPO terms are then stored in an AffineDecomposition as ApproxMPOs which also include possible truncation keyword arguments:","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"function xxz_chain(sites::IndexSet; kwargs...)\n    xy_term   = OpSum()\n    zz_term   = OpSum()\n    magn_term = OpSum()\n    for i in 1:(length(sites) - 1)\n        xy_term   += 0.5, \"S+\", i, \"S-\", i + 1\n        xy_term   += 0.5, \"S-\", i, \"S+\", i + 1\n        zz_term   +=      \"Sz\", i, \"Sz\", i + 1\n        magn_term +=      \"Sz\", i\n    end\n    magn_term += \"Sz\", length(sites)  # Add last magnetization term\n    coefficient_map = μ -> [1.0, μ[1], -μ[2]]\n    AffineDecomposition([ApproxMPO(MPO(xy_term, sites), xy_term; kwargs...),\n                        ApproxMPO(MPO(zz_term, sites), zz_term; kwargs...),\n                        ApproxMPO(MPO(magn_term, sites), magn_term; kwargs...)],\n                        coefficient_map)\nend","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"So let us instantiate such an MPO Hamiltonian where we also specify a singular value cutoff, which is passed to the ApproxMPO objects:","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"L = 18\nsites = siteinds(\"S=1/2\", L)\nH = xxz_chain(sites; cutoff=1e-9)","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"Notice that we can now choose a bigger system size (which is still very small here), since the tensor format allows for efficient low rank approximations (hence the cutoff) that buy us a substantial performance advantage when going to larger systems.","category":"page"},{"location":"examples/xxz_dmrg/#Using-the-[DMRG](@ref)-solver-for-basis-assembly","page":"Greedy basis assembly using DMRG","title":"Using the DMRG solver for basis assembly","text":"","category":"section"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"Having created our Hamiltonian in MPO format, we now need a solver that is able to compute ground states from MPOs. The corresponding ground state will also be obtained in a tensor format, namely as a matrix product state (MPS). This is achieved by ITensors.dmrg which is wrapped in the DMRG solver type:","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"dm = DMRG(; n_states=1, tol_degeneracy=0.0,\n          sweeps=default_sweeps(; cutoff_max=1e-9, bonddim_max=1000),\n          observer=() -> DMRGObserver(; energy_tol=1e-9))","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"While the implemented DMRG solver is capable of solving degenerate ground states, we here opt for non-degenerate settings, i.e. n_states=1 and tol_degeneracy=0.0. (We do this due to a L+1-fold degeneracy on the parameter domain, where the degenerate DMRG solver can produce instable results for larger L.)","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"As discussed in the last example, we need a way to orthogonalize the reduced basis. Due to the MPS format that the snapshots will have, we cannot use QR decompositions anymore and resort to a different method, EigenDecomposition, featuring an eigenvalue decomposition of the snapshot overlap matrix that can drop insignificant snapshots that fall below a cutoff:","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"edcomp = EigenDecomposition(; cutoff=1e-7)","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"Δ = range(-1.0, 2.5; length=40) # hide\nhJ = range(0.0, 3.5; length=40) # hide\ngrid_train = RegularGrid(Δ, hJ) # hide\ngreedy = Greedy(; estimator=Residual(), n_truth_max=32, init_from_rb=true) # hide","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"Now with different types for the Hamiltonian, the solver and the orthogonalizer, we call assemble using the greedy strategy and training grid from the last example:","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"info = assemble(H, grid_train, greedy, dm, edcomp)\nbasis = info.basis; h = info.h_cache.h;","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"The returned basis now has snapshot vectors of ITensors.MPS type, which we have to keep in mind when we want to compress observables. That is to say, the observables have to be constructed as AffineDecompositions with ApproxMPO terms as we did for the Hamiltonian. Again, we want to compute the magnetization so that we can reuse the third term of H:","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"M = AffineDecomposition([H.terms[3]], μ -> [2 / L])\nm, _ = compress(M, basis)","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"m_reduced = m([1]) # hide\nΔ_online = range(first(Δ), last(Δ); length=100) # hide\nhJ_online = range(first(hJ), last(hJ); length=100) # hide\ngrid_online = RegularGrid(Δ_online, hJ_online) # hide\n\nfulldiag = FullDiagonalization(dm)  # hide\nmagnetization = map(grid_online) do μ # hide\n    _, φ_rb = solve(h, basis.metric, μ, fulldiag)  # hide\n    sum(eachcol(φ_rb)) do u # hide\n        abs(dot(u, m_reduced, u)) / size(φ_rb, 2)  # hide\n    end # hide\nend # hide","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"And at that point, we continue as before since we have arrived at the online phase where we only operate in the low-dimensional reduced basis space, agnostic of the snapshot solver method. We have to make sure, however, to choose matching degeneracy settings for the FullDiagonalization solver in the online phase:","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"fulldiag = FullDiagonalization(dm)","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"m_reduced = m([1]) # hide\nΔ_online = range(first(Δ), last(Δ); length=100) # hide\nhJ_online = range(first(hJ), last(hJ); length=100) # hide\ngrid_online = RegularGrid(Δ_online, hJ_online) # hide\n\nmagnetization = map(grid_online) do μ # hide\n    _, φ_rb = solve(h, basis.metric, μ, fulldiag) # hide\n    sum(eachcol(φ_rb)) do u # hide\n        abs(dot(u, m_reduced, u)) # hide\n    end / size(φ_rb, 2) # hide\nend # hide","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"In the same way as before, we perform the online computations and arrive at the following magnetization plot:","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"hm = heatmap(grid_online.ranges[1], grid_online.ranges[2], magnetization';\n             xlabel=raw\"$\\Delta$\", ylabel=raw\"$h/J$\", title=\"magnetization \",\n             colorbar=true, clims=(0.0, 1.0), leg=false)\nplot!(hm, grid_online.ranges[1], x -> 1 + x; lw=2, ls=:dash, legend=false, color=:green)\nparams = unique(basis.parameters)\nscatter!(hm, [μ[1] for μ in params], [μ[2] for μ in params];\n         markershape=:xcross, color=:springgreen, ms=3.0, msw=2.0)","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"We reproduce the ground state phase diagram, but this time with more magnetization plateaus (due to increased system size) and we see that the greedy algorithm chose different parameter points to solve using DMRG.","category":"page"},{"location":"#ReducedBasis.jl","page":"Home","title":"ReducedBasis.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ReducedBasis.jl is a Julia package that uses the reduced basis method (RBM) to accelerate the solution of a parametrized eigenvalue problems across the parameter domain.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the RBM approach, a surrogate model is assembled by projecting the full problem onto a basis consisting of only a few tens of parameter snapshots. The package focuses on a greedy strategy that selects snapshots by maximally reducing the estimated error with each additional snapshot. Once the RBM surrogate is assembled, physical observables can be computed for any parameter value with only a modest complexity, which scales independently from the dimension of the initial eigenvalue problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, the motivating application resides in quantum spin systems, following recent developments of RBM approaches in quantum many-body physics. Nonetheless ReducedBasis is intended to be generally applicable to parametrized eigenvalue problems with a low-dimensional parameter space. Key steps of the RBM procedure, such as the snapshot solving method, error estimates or the assembly strategy, can therefore be easily customized. Moreover, the package integrates with ITensors.jl that allows the use of tensor network methods, in particular the density matrix renormalization group using matrix product states.","category":"page"}]
}
