var documenterSearchIndex = {"docs":
[{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"EditURL = \"https://github.com/mfherbst/ReducedBasis.jl/blob/master/examples/basis_analysis.jl\"","category":"page"},{"location":"examples/basis_analysis/#Analyzing-and-modifying-a-reduced-basis-after-assembly","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"","category":"section"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"When solving parametrized eigenvalue problems using surrogates, the important question arises, to what degree the surrogate actually reflects the behavior of the original problem. In particular, one needs to know if the surrogate contains artifacts that propagate to online measurements of observables. One possibility to evaluate the surrogate quality is the direct comparison of observables and vectors obtained from the reduced basis and truth solver. This, however, is a numerically demanding approach which we will not cover here. So in this example we want to showcase some of the tools that can be used to analyze and correct an assembled basis in the online stage and in a computationally cheap way.","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"Before going into the specifics, we first setup an example for which we use the XXZ chain where the snapshots are obtained using DMRG (see Greedy basis assembly using DMRG).","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"using LinearAlgebra\nusing ITensors\nusing ReducedBasis\nusing Random: seed!\nseed!(0)  # seed to make example consistent\n\nfunction xxz_chain(sites::IndexSet; kwargs...)\n    xy_term   = OpSum()\n    zz_term   = OpSum()\n    magn_term = OpSum()\n    for i in 1:(length(sites) - 1)\n        xy_term   += \"Sx\", i, \"Sx\", i + 1\n        xy_term   += \"Sy\", i, \"Sy\", i + 1\n        zz_term   += \"Sz\", i, \"Sz\", i + 1\n        magn_term += \"Sz\", i\n    end\n    magn_term += \"Sz\", length(sites)  # Add last magnetization term\n    coefficients = μ -> [1.0, μ[1], -μ[2]]\n    AffineDecomposition([ApproxMPO(MPO(xy_term, sites), xy_term; kwargs...),\n                         ApproxMPO(MPO(zz_term, sites), zz_term; kwargs...),\n                         ApproxMPO(MPO(magn_term, sites), magn_term; kwargs...)],\n                        coefficients)\nend\n\nL = 12\nsites = siteinds(\"S=1/2\", L)\nH = xxz_chain(sites; cutoff=1e-9)\ndm = DMRG()\nΔ = range(-1.0, 2.5; length=40)\nhJ = range(0.0, 3.5; length=40)\ngrid_train = RegularGrid(Δ, hJ);\nnothing #hide","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"Up to this points we chose reasonable parameters for the basis assembly. However, we now intend to generate a bad surrogate with purposefully bad settings.","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"warning: Bad settings\nThe offline settings that are chosen here and also later in the example are intentionally chosen to produce unconverged (and thus wrong) results, i.e. the \"side effects\" observed in this example should not happen in real applications and would indicate inappropriate parameters.","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"Namely, we limit our basis size to n_truth_max=6 truth solves and use a compression cutoff of cutoff=1e-10 which is lower than the energy and singular value cutoff above:","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"greedy = Greedy(; estimator=Residual(), n_truth_max=8)\nedcomp = EigenDecomposition(; cutoff=0.0);\nnothing #hide","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"We therefore let unphysical modes eventually enter our basis. The first useful object that we encounter is the InfoCollector that can be used to collect various quantities that are computed in each greedy iteration. We chain the collector together with the print_callback via the ∘ operator and use the resulting function as the callback function during assembly:","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"collector = InfoCollector(:basis, :h_cache)\nrbres = assemble(H, grid_train, greedy, dm, edcomp;\n                 callback=collector ∘ print_callback);\nnothing #hide","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"Using this presumably inaccurate surrogate, we compute the magnetization","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"M = AffineDecomposition([H.terms[3]], [2 / L])\nm, _ = compress(M, rbres.basis)\nm_reduced = m();\nnothing #hide","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"on a finer online grid using the matching online solver","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"Δ_online    = range(first(Δ), last(Δ); length=100)\nhJ_online   = range(first(hJ), last(hJ); length=100)\ngrid_online = RegularGrid(Δ_online, hJ_online)\nfulldiag    = FullDiagonalization(dm);\nnothing #hide","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"and additionally save all computed reduced basis vectors for later analysis:","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"using Statistics\nrbvecs = similar(grid_online, Matrix{ComplexF64})\nmagnetization = similar(grid_online, Float64)\nfor (idx, μ) in pairs(grid_online)\n    _, φ_rb = solve(rbres.h, rbres.basis.metric, μ, fulldiag)\n    rbvecs[idx] = φ_rb\n    magnetization[idx] = mean(u -> abs(dot(u, m_reduced, u)), eachcol(φ_rb))\nend","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"We then end up with a magnetization heatmap that significantly deviates from the correct phase diagram (compare e.g. with Greedy basis assembly using DMRG):","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"using Plots\nxrange, yrange = grid_online.ranges[1], grid_online.ranges[2]\nparams = unique(rbres.basis.parameters)\nxpoints, ypoints = [μ[1] for μ in params], [μ[2] for μ in params]\nhm_kwargs = (; xlabel=raw\"$\\Delta$\", ylabel=raw\"$D/J$\", colorbar=true, leg=false)\nmarker_kwargs = (; markershape=:xcross, mcolor=:springgreen, ms=3.0, msw=2.0);\n\nhm = heatmap(xrange, yrange, magnetization';\n             clims=(0.0, 1.0), title=\"magnetization\", hm_kwargs...)\nscatter!(hm, xpoints, ypoints; marker_kwargs...)","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"So what happened here (on purpose) is that the reduced basis does not contain enough snapshots to fully resolve all features of the true phase diagram. To further dissect the problems, let us look at some of the possible ways to analyze the basis, based on the quantities we already have at our disposal.","category":"page"},{"location":"examples/basis_analysis/#Online-diagnostics","page":"Analyzing and modifying a reduced basis after assembly","title":"Online diagnostics","text":"","category":"section"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"To visualize the degree to which the different snapshot vectors are \"mixed\" in the online reduced basis vectors, we can compute the so-called participation ratio","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"mathrmPR(varphi) = frac1d frac1sum_k=1^d varphi_k^4","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"where we assume the RB vector varphi to normalized. For a maximally mixing RB vector with elements varphi_k = 1sqrtd the participation ratio becomes maximal, whereas a unit vector would produce the minimal participation ratio. The RB vectors from before produce the following mathrmPR:","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"d = dimension(rbres.basis)\npr = map(rbvecs) do φ\n    1 / (d * sum(x -> abs2(x)^2, φ))\nend\n\nhm = heatmap(xrange, yrange, pr'; title=\"participation ratio\", hm_kwargs...)\nscatter!(hm, xpoints, ypoints; marker_kwargs...)","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"Another way to look at the online vectors is to find the maximal coefficient of each vector on the online grid and then assign it a color. The resulting heatmap displays — depending on the compression method — Voronoi-like cells around the snapshot parameter points. Using the collected info contained in the collector, we can even animate these cells with respect to the greedy iterations:","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"anim = @animate for n in 1:dimension(rbres.basis)\n    data = collector.data\n    vecs = map(grid_online) do μ\n        solve(data[:h_cache][n].h, data[:basis][n].metric, μ, fulldiag)[2]\n    end\n    voronoi = map(φ -> findmax(abs.(@view φ[:, 1]))[2], vecs)\n    hm = heatmap(xrange, yrange, voronoi';\n                 title=\"Voronoi\", clims=(1, 8), hm_kwargs...)\n    p = unique(data[:basis][n].parameters)\n    scatter!(hm, [μ[1] for μ in p], [μ[2] for μ in p]; marker_kwargs...)\nend\ngif(anim; fps=0.7)","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"We see that with each new snapshot we map out a new domain the parameter space. Hence to further resolve the phase diagram, we will need to add more snapshots.","category":"page"},{"location":"examples/basis_analysis/#Continuing-an-assembly","page":"Analyzing and modifying a reduced basis after assembly","title":"Continuing an assembly","text":"","category":"section"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"To continue assembling a basis, we can just call assemble and provide the rbres tuple from the previous greedy assembly. Of course the remaining arguments can be adjusted in the continued assembly, so let us now increase the maximal number of truth solves:","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"greedy_cont = Greedy(; estimator=Residual(), n_truth_max=36)\nrbres_cont = assemble(rbres, H, grid_train, greedy_cont, dm, edcomp);\nnothing #hide","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"Apparently the assembly was stopped since an already solved snapshot was about to be solved again — which cannot happen in a correctly assembled greedy basis, indicating that the online evaluations of observables will contain artifacts. So let us check that by recomputing the magnetization using the continued basis:","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"m_cont, m_cont_raw = compress(M, rbres_cont.basis)\nm_reduced_cont = m_cont()\n\nmagn_cont = map(grid_online) do μ\n    _, φ_rb = solve(rbres_cont.h_cache.h, rbres_cont.basis.metric, μ, fulldiag)\n    mean(u -> abs(dot(u, m_reduced_cont, u)), eachcol(φ_rb))\nend\nhm = heatmap(xrange, yrange, magn_cont';\n             clims=(0.0, 1.0), title=\"continued magnetization\", hm_kwargs...)\nparams = unique(rbres_cont.basis.parameters)\nscatter!(hm, [μ[1] for μ in params], [μ[2] for μ in params]; marker_kwargs...)","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"Indeed the magnetization heatmap seems to be broken (again compare with Greedy basis assembly using DMRG); the phase diagram contains a large artifact related to the M=0 plateau. In these cases, we need to fix the reduced basis by removing snapshots from it.","category":"page"},{"location":"examples/basis_analysis/#Truncation-of-snapshots","page":"Analyzing and modifying a reduced basis after assembly","title":"Truncation of snapshots","text":"","category":"section"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"Fortunately, the greedy assembly is irreversible, meaning we can truncate our RBasis to a desired number of truth solves. Let us remove the last few snapshots to correct the error incurred by repeated MPS approximations:","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"basis_trunc = truncate(rbres_cont.basis, 30);\nnothing #hide","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"Since we performed multiple compressions using the previous rbres_cont.basis, we also need to truncate the HamiltonianCache according to the truncated basis:","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"h_cache_trunc = truncate(rbres_cont.h_cache, basis_trunc);\nnothing #hide","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"A slightly more subtle thing occurs with the compressed AffineDecompositions. Here we need to provide the second return argument m_cont_raw of the compressed magnetization from above:","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"m_trunc = truncate(m_cont_raw, basis_trunc)\nm_reduced_trunc = m_trunc();\nnothing #hide","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"Finally, let us recompute the magnetization but this time with the truncated quantities and check the heatmap plot:","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"magn_trunc = map(grid_online) do μ\n    _, φ_rb = solve(h_cache_trunc.h, basis_trunc.metric, μ, fulldiag)\n    mean(u -> abs(dot(u, m_reduced_trunc, u)), eachcol(φ_rb))\nend\nhm = heatmap(xrange, yrange, magn_trunc';\n             clims=(0.0, 1.0), title=\"truncated magnetization\", hm_kwargs...)\nparams = unique(basis_trunc.parameters)\nscatter!(hm, [μ[1] for μ in params], [μ[2] for μ in params]; marker_kwargs...)","category":"page"},{"location":"examples/basis_analysis/","page":"Analyzing and modifying a reduced basis after assembly","title":"Analyzing and modifying a reduced basis after assembly","text":"By truncating the basis and all compressed quantities, we have recovered the phase diagram. This process did not involve any computationally expensive operations and can therefore be always performed as a consistency check on a generated basis.","category":"page"},{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [ReducedBasis]","category":"page"},{"location":"api/#ReducedBasis.AffineDecomposition","page":"API reference","title":"ReducedBasis.AffineDecomposition","text":"Represents an affine decomposition\n\nO(bmmu) = sum_r=1^R alpha_r(bmmu) O_r\n\nwhere terms<:AbstractArray carries the O_r matrices (or more generally linear maps) and the coefficients implements the alpha_r(bmmu) coefficient functions.\n\nIn the case where the alpha_r are constant coefficients, i.e. that don't depend on the parameter vector, coefficients can also just be an AbstractArray of the same size as terms.\n\nNote that r = (r_1 dots r_d) generally is a multi-index and as such terms can be a d-dimensional array. Correspondingly, coefficients maps parameter points bmmu to an size(terms) array.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.AffineDecomposition-Tuple{Any}","page":"API reference","title":"ReducedBasis.AffineDecomposition","text":"(ad::AffineDecomposition{<:AbstractArray{<:ApproxMPO}})(μ)\n\nCompute sum with ApproxMPOs using the exact ITensors operator sum.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.ApproxMPO","page":"API reference","title":"ReducedBasis.ApproxMPO","text":"Carries an ITensors.MPO matrix-product operator and possible truncation keyword arguments.\n\nThis enables a simple mpo * mps syntax while allowing for proper truncation throughout the basis assembly. Includes the exact operator sum in opsum to be able to produce efficient sums of MPOs when constructing AffineDecomposition sums explicitly.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.ApproxMPO-Tuple{ITensors.MPO, Any}","page":"API reference","title":"ReducedBasis.ApproxMPO","text":"ApproxMPO(mpo::MPO, opsum; <keyword arguments>)\n\nConstruct an ApproxMPO with default truncation settings.\n\nArguments\n\nmpo::MPO\nopsum::Sum{Scaled{ComplexF64,Prod{Op}}}\ncutoff::Float64=1e-9: relative cutoff for singular values.\nmaxdim::Int=1000: maximal bond dimension.\nmindim::Int=1: minimal bond dimension.\ntruncate::Bool=true: disables all truncate if set to false.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.DMRG","page":"API reference","title":"ReducedBasis.DMRG","text":"Solver type for the density matrix renormalization group (DMRG) as implemented in ITensors.dmrg.\n\nFields\n\nn_states::Int=1: see FullDiagonalization.\ntol_degeneracy::Float64=0.0: see FullDiagonalization.\nsweeps::Sweeps=default_sweeps(; cutoff_max=1e-9, bonddim_max=1000): set DMRG sweep settings via ITensors.Sweeps.\nobserver::Function=() -> DMRGObserver(; energy_tol=1e-9): set DMRG exit conditions. At each solve a new ITensors.AbstractObserver object is created.\nverbose::Bool=false: if true, prints info about DMRG solve.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.EigenDecomposition","page":"API reference","title":"ReducedBasis.EigenDecomposition","text":"Extension type for orthogonalization and compression using eigenvalue decomposition of the basis overlap matrix. See also extend.\n\nFields\n\ncutoff::Float64=1e-6: cutoff for minimal eigenvalue accuracy.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.ErrorEstimate","page":"API reference","title":"ReducedBasis.ErrorEstimate","text":"Super type of all error estimators.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.FullDiagonalization","page":"API reference","title":"ReducedBasis.FullDiagonalization","text":"Solver type for full diagonalization using LinearAlgebra.eigen.\n\nFields\n\nn_target::Int=1: the number of the targeted eigenvalue. If n_target=1, the degeneracy of the ground state is automatically determined up to tol_degeneracy. If tol_degeneracy=0, it determines the number of returned vectors per solve (also includes excited states).\ntol_degeneracy::Float64=0.0: tolerance for distinguishing two eigenvalues. If abs(λ₁ - λ₂) < tol_degeneracy, the eigenvalues are added to the same degenerate subspace.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.FullDiagonalization-Tuple{DMRG}","page":"API reference","title":"ReducedBasis.FullDiagonalization","text":"FullDiagonalization(dm::DMRG)\n\nConstruct FullDiagonalization with the same degeneracy tolerance as dm and fix n_target=1.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.FullDiagonalization-Tuple{LOBPCG}","page":"API reference","title":"ReducedBasis.FullDiagonalization","text":"FullDiagonalization(lobpcg::LOBPCG)\n\nConstruct the FullDiagonalization solver with degeneracy settings matching lobpcg.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.Greedy","page":"API reference","title":"ReducedBasis.Greedy","text":"Greedy reduced basis assembling strategy.\n\nFields\n\nestimator::ErrorEstimate: error estimate used in greedy condition. See also estimate_error\ntol::Float64=1e-3: tolerance for error estimate, below which the assembly is terminated.\nn_truth_max::Int=64: maximal number of truth solves to be taken up in the basis.\nΨ_init::Function=rb_guess: returns initial guess for truth solver. See also interpolate.\nverbose::Bool=true: print information during assembly if true.\nexit_checks::Bool=true: if false, no exit checks will be performed and the assembly will run until tol or n_truth_max are reached.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.HamiltonianCache","page":"API reference","title":"ReducedBasis.HamiltonianCache","text":"Convenience type storing a Hamiltonian, its applications to vectors and its compressions.\n\nFields\n\nH::AffineDecomposition\nHΨ::Vector{V}\nΨHΨ::Vector{Matrix{T}}\nΨHHΨ::Matrix{Matrix{T}}\nh::AffineDecomposition\nh²::AffineDecomposition\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.HamiltonianCache-Tuple{AffineDecomposition, RBasis}","page":"API reference","title":"ReducedBasis.HamiltonianCache","text":"HamiltonianCache(H::AffineDecomposition, basis::RBasis)\n\nConstruct HamiltonianCache from a Hamiltonian computing all applications and compressions with an reduced basis.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.HamiltonianCache-Union{Tuple{T}, Tuple{V}, Tuple{HamiltonianCache, RBasis{V, T}}} where {V, T}","page":"API reference","title":"ReducedBasis.HamiltonianCache","text":"HamiltonianCache(hc::HamiltonianCache, basis::RBasis{V,T}) where {V,T}\n\nConstruct from previous HamiltonianCache, only computing necessary Hamiltonian applications and inner products.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.InfoCollector","page":"API reference","title":"ReducedBasis.InfoCollector","text":"Carries a Dict of Vectors which contain information from greedy assembly iterations.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.InfoCollector-Tuple{Any}","page":"API reference","title":"ReducedBasis.InfoCollector","text":"(collector::InfoCollector)(info)\n\nPush iteration information into InfoCollector and return info object, containing the InfoCollector itself.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.InfoCollector-Tuple{Vararg{Symbol}}","page":"API reference","title":"ReducedBasis.InfoCollector","text":"InfoCollector(fields::Symbol...)\n\nConstruct InfoCollector from fields that are contained in the info iteration state object. Possible fields to select from are:\n\niteration: number of iteration at which the information was obtained.\nerr_grid: error estimate on all parameter points of the training grid.\nλ_grid: RB energies on all training grid points.\nerr_max: maximal error estimate on the grid.\nμ: parameter point at which truth solve has been performed.\nsolver_info: output of the solving method, which excludes eigenvalues and vectors.\nbasis: RBasis at the current iteration.\nextend_info: info that is specific to the chosen extension procedure, not including\n\nthe extended RBasis.\n\ncondnum: condition number of the B^dagger B.\nh: current reduced Hamiltonian.\nh_cache: HamiltonianCache at the current iteration.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.LOBPCG","page":"API reference","title":"ReducedBasis.LOBPCG","text":"Solver type for the Locally Optimal Block Preconditioned Conjugate Gradient (LOBPCG). Currently uses the DFTK lobpcg_hyper implementation.\n\nFields\n\nn_target::Int=1: see FullDiagonalization.\ntol_degeneracy::Float64=0.0: see FullDiagonalization.\ntol::Float64=1e-9: tolerance for residual norms.\nmaxiter::Int=300: maximal number of LOBPCG iterations.\nn_ep_extra::Int=4: number of extra eigenpairs that are kept to improve convergence.\nshift::Float64=-100: eigenvalue shift.\nverbose::Bool=false: if true, print convergence messages.\ndense_fallback::Bool=true: if false, also non-converged states will be accepted. Otherwise LinearAlgebra.eigen is used for non-converged iterations.\nmaxdiagonal::Int=400\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.NoCompress","page":"API reference","title":"ReducedBasis.NoCompress","text":"Extension type for no orthonormalization or compression. See also extend.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.POD","page":"API reference","title":"ReducedBasis.POD","text":"Proper orthogonal decomposition assembly strategy.\n\nFields\n\nn_vectors::Int: number of retained singular vectors of the snapshot matrix in the returned basis.\nverbose::Bool=true: shows the truth solve progress if true.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.QRCompress","page":"API reference","title":"ReducedBasis.QRCompress","text":"Extension type for QR orthonormalization and compression. See extend for details.\n\nFields\n\ntol::Float64: tolerance for compressing insignificant basis snapshots.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.RBasis","page":"API reference","title":"ReducedBasis.RBasis","text":"Central type containing snapshots and associated objects that make a reduced basis.\n\nThe snapshot vectors are contained in snapshots::AbstractVector{V} where the snapshots are of type V. Here a \"snapshot\" refers to all vectors that were obtained from a solve at a specific parameter point. For greedy-generated bases, each element in snapshots has a parameter point in parameter::Vector{P}, i.e. for snapshots bmPsi(bmmu_i) = (Psi_1(bmmu_i)dotsPsi_m(bmmu_i)) of multiplicity m the parameter point bmmu is contained m times. However, for general basis-assembly strategies this one-to-one correspondence might not be true, e.g. for POD where snapshots contains singular vectors based on all truth solves.\n\nTreated as a matrix, the reduced basis B = Upsilon V is made up of the snapshot vectors as column vectors in Upsilon and vector coefficients V. The latter are stored in vectors. In the simple case of B = Upsilon, one sets vectors=I.\n\nSince the matrix B^dagger B = V^dagger Upsilon^dagger Upsilon V is frequently needed, both the snapshot_overlaps Upsilon^dagger Upsilon and the metric B^dagger B are stored with generic floating-point type T.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.RegularGrid","page":"API reference","title":"ReducedBasis.RegularGrid","text":"Stores equidistant grid of parameter points as well as its interval ranges.\n\n\n\n\n\n","category":"type"},{"location":"api/#ReducedBasis.RegularGrid-Tuple{Vararg{StepRangeLen}}","page":"API reference","title":"ReducedBasis.RegularGrid","text":"RegularGrid(ranges::StepRangeLen...)\n\nConstruct a D-dimensional RegularGrid from D ranges.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.Residual","page":"API reference","title":"ReducedBasis.Residual","text":"Estimator type for the residual mathrmRes(bmmu) = lVert H(bmmu) B varphi(bmmu) - lambda B varphi(bmmu) rVert.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.:*-Tuple{ApproxMPO, ITensors.MPS}","page":"API reference","title":"Base.:*","text":"*(o::ApproxMPO, mps::MPS)\n\nApply o.mpo to mps using the truncation arguments contained in o.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.truncate-Tuple{AffineDecomposition, RBasis}","page":"API reference","title":"Base.truncate","text":"Base.truncate(ad_raw::AffineDecomposition, basis_trunc::RBasis)\nBase.truncate(ad::AffineDecomposition,\n              basis_trunc::RBasis{V,T,P,<:UniformScaling}) where {V,T<:Number,P}\n\nTruncate an AffineDecomposition.\n\nFor general RBasis, the \"raw\" AffineDecomposition has to be provided, where ad_raw.terms are the matrix elements Psi_i^dagger O_r Psi_j. The returned decomposition then contains the fully compressed transformed terms, i.e. B^dagger O_r B using the truncated basis.\n\nIn case a basis is provided that has trivial vectors=I, the truncation is performed naively on the fully compressed terms.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.truncate-Tuple{HamiltonianCache, RBasis}","page":"API reference","title":"Base.truncate","text":"Base.truncate(hc::HamiltonianCache, basis_trunc::RBasis)\n\nTruncate a [HamiltonianCache] according to an already truncated basis.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.truncate-Tuple{RBasis, Int64}","page":"API reference","title":"Base.truncate","text":"Base.truncate(basis::RBasis, n_truth::Int)\n\nTruncate the RBasis to n_truth snapshots.\n\nNote that n_truth does not amount to the dimension of the truncated basis, but the number of truth solves included in the basis, which can feature degenerate snapshots.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.assemble-Tuple{AffineDecomposition, Any, POD, Any}","page":"API reference","title":"ReducedBasis.assemble","text":"assemble(H::AffineDecomposition, grid, pod::POD, solver_truth)\n\nAssemble basis using POD.\n\nOnly ED solvers such as FullDiagonalization and LOBPCG are supported. The generated RBasis will contain pod.n_vectors singular vectors in snapshots and all grid points in parameters. This means that parameters and snapshots generally have different lengths.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.assemble-Tuple{NamedTuple, AffineDecomposition, Any, Greedy, Any, Any}","page":"API reference","title":"ReducedBasis.assemble","text":"assemble(H, grid, greedy, solver_truth, compressalg; <keyword arguments>)\nassemble(info, H, grid, greedy, solver_truth, compressalg; <keyword arguments>)\n\nAssemble an RBasis using the greedy strategy and any truth solving method.\n\nIf info is not provided, start a greedy assembly from scratch.\n\nArguments\n\ninfo::NamedTuple: iteration state from a previous simulation that will be resumed.\nH::AffineDecomposition: Hamiltonian for which a reduced basis is assembled.\ngrid: parameter grid that defines the parameter domain.\ngreedy::Greedy: greedy strategy containing assembly parameters. See also Greedy.\nsolver_truth: solving method for obtaining ground state snapshots.\ncompressalg: compression method for orthogonalization, etc. See also extend.\nsolver_online=FullDiagonalization(solver_truth): solving method that is used for the RB generalized eigenvalue problem.\ncallback=print_callback: callback function that operates on the iteration state during assembly. It is possible to chain multiple callback functions using ∘.\nμ_start=grid[1]: parameter point of the starting iteration, if no info is provided.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.bounds-Union{Tuple{RegularGrid{D}}, Tuple{D}} where D","page":"API reference","title":"ReducedBasis.bounds","text":"bounds(grid::RegularGrid{D}) where {D}\n\nReturn SVector of grid boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.compress-Tuple{AbstractMatrix, AbstractVector{<:AbstractVector}}","page":"API reference","title":"ReducedBasis.compress","text":"compress(M::AbstractMatrix, snapshots::AbstractVector{<:AbstractVector})\n\nCompress term using matrix multiplications.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.compress-Tuple{AffineDecomposition, RBasis}","page":"API reference","title":"ReducedBasis.compress","text":"compress(ad::AffineDecomposition, basis::RBasis)\n\nPerform the compression of an AffineDecomposition corresponding to o = B^dagger O B.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.compress-Tuple{AffineDecomposition{<:Matrix}, RBasis}","page":"API reference","title":"ReducedBasis.compress","text":"compress(ad::AffineDecomposition{<:Matrix,<:Function},\n         basis::RBasis; symmetric_terms=false)\n\nPerform compression for an AffineDecomposition with terms with two indices (double-sum observables), including an option to exploit the possible symmetry of terms O_rr = O_rr, such that only the necessary compressions are computed.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.compress-Tuple{Any, AbstractVector}","page":"API reference","title":"ReducedBasis.compress","text":"compress(op, snapshots::AbstractVector)\n\nCompress one term of an AffineDecomposition ApproxMPO type.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.default_sweeps-Tuple{}","page":"API reference","title":"ReducedBasis.default_sweeps","text":"default_sweeps(; cutoff_max=1e-9, bonddim_max=1000, iter_max=100)\n\nReturn default ITensors.Sweeps object for DMRG solves, containing decreasing noise and increasing maximal bond dimension ramps.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.dimension-Tuple{RBasis}","page":"API reference","title":"ReducedBasis.dimension","text":"dimension(basis::RBasis)\n\nReturn the basis dimension dim B.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.estimate_error-Tuple{Residual, Any, HamiltonianCache, RBasis, Any}","page":"API reference","title":"ReducedBasis.estimate_error","text":"estimate_error(::Residual, μ, h_cache::HamiltonianCache, basis::RBasis, sol_rb)\n\nEstimate error of reduced basis using the Residual estimator.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.extend-Tuple{RBasis, AbstractVector, Any, EigenDecomposition}","page":"API reference","title":"ReducedBasis.extend","text":"extend(basis::RBasis, new_snapshot::AbstractVector, μ, ed::EigenDecomposition)\n\nExtend the reduced basis by orthonormalizing and compressing via eigenvalue decomposition.\n\nThe overlap matrix S in basis.snapshot_overlaps is eigenvalue decomposed S = U^dagger Lambda U and orthonormalized by computing the vector coefficients V = U Lambda^-12. Modes with an relative squared eigenvalue error smaller than ed.cutoff are dropped.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.extend-Tuple{RBasis, AbstractVector, Any, NoCompress}","page":"API reference","title":"ReducedBasis.extend","text":"extend(basis::RBasis, new_snapshot, μ, ::NoCompress)\n\nExtend the reduced basis by one snapshot without any orthogonalization or compression procedure.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.extend-Tuple{RBasis, AbstractVector, Any, QRCompress}","page":"API reference","title":"ReducedBasis.extend","text":"extend(basis::RBasis, new_snapshot::AbstractVector, μ, qrcomp::QRCompress)\n\nExtend using QR orthonormalization and compression.\n\nThe orthonormalization is performed by QR decomposing the orthogonal projection bmPsi(bmmu_n+1) - B_n^dagger B_n^dagger B_n^-1 B_n bmPsi(bmmu_n) and appending Q to snapshots. Modes that have an R column maximum falling below the qrcomp.tol tolerance are dropped.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.extend_overlaps-Tuple{Matrix, Vector, Vector}","page":"API reference","title":"ReducedBasis.extend_overlaps","text":"extend_overlaps(old_overlaps::Matrix, old_snapshots::Vector, new_snapshot::Vector)\n\nExtend an overlap matrix by one snapshot, where only the necessary dot products are computed.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.in_bounds-Tuple{Any, RegularGrid}","page":"API reference","title":"ReducedBasis.in_bounds","text":"in_bounds(μ, grid::RegularGrid)\n\nCheck whether a given parameter point μ is in the convex hull of the grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.interpolate-Tuple{RBasis, AffineDecomposition, Any, Any}","page":"API reference","title":"ReducedBasis.interpolate","text":"interpolate(basis::RBasis, h::AffineDecomposition, μ, solver_online)\n\nCompute Hilbert-space-dimensional ground state vector at parameter point μ from the reduced basis using bmPhi(bmmu) = B bmvarphi(bmmu).\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.interpolate-Tuple{RBasis{ITensors.MPS}, AffineDecomposition, Any, Any}","page":"API reference","title":"ReducedBasis.interpolate","text":"interpolate(basis::RBasis{MPS}, h::AffineDecomposition, μ, dm::DMRG, solver_online)\n\nCompute ground state MPS at μ from the reduced basis by MPS addition in  Phi(bmmu) rangle = sum_k=1^dim B V varphi(bmmu_k)_k  Psi(bmmu_k) rangle.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.mps_callback-Tuple{Any}","page":"API reference","title":"ReducedBasis.mps_callback","text":"mps_callback(info)\n\nPrint maximal bond dimension, truncation error and other MPS diagnostics.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.multiplicity-Tuple{RBasis}","page":"API reference","title":"ReducedBasis.multiplicity","text":"multiplicity(basis::RBasis)\n\nReturn the multiplicity of each truth solve.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.n_truthsolve-Tuple{RBasis}","page":"API reference","title":"ReducedBasis.n_truthsolve","text":"n_truthsolve(basis::RBasis)\n\nReturn the number of truth solves (snapshots) contained in the basis.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.overlap_matrix-Tuple{Vector, Vector}","page":"API reference","title":"ReducedBasis.overlap_matrix","text":"overlap_matrix(v1::Vector, v2::Vector)\n\nCompute the overlap matrix of two sets of vector-like objects v1 and v2.\n\nThe computed matrix elements are the dot products dot(v1[i], v2[j]). Correspondingly, the elements of v1 and v2 must support a LinearAlgebra.dot method. In the case where v1 = v2, the Gram matrix is computed.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.print_callback-Tuple{Any}","page":"API reference","title":"ReducedBasis.print_callback","text":"print_callback(info)\n\nPrint diagnostic information at each assembly iteration.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.random_guess-Tuple{Any, Any}","page":"API reference","title":"ReducedBasis.random_guess","text":"random_guess(info, offline_args)\n\nProvides a random initial guess according to the truth solver method.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.rb_guess-Tuple{Any, Any}","page":"API reference","title":"ReducedBasis.rb_guess","text":"rb_guess(info, offline_args; kwargs...)\n\nProvide the reduced basis interpolated ground state as an initial guess for the truth solver.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.reconstruct-Tuple{ITensors.MPS}","page":"API reference","title":"ReducedBasis.reconstruct","text":"reconstruct(mps::MPS)\n\nExplicitly compute Hilbert-space-dimensional vector by reconstructing all MPS coefficients.\n\nwarning: Memory restrictions\nThe number of MPS coefficients grows exponentially with system size, such that the explicit reconstruction is only possible for small systems.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.shift-Union{Tuple{N}, Tuple{D}, Tuple{RegularGrid{D, N}, Any}} where {D, N}","page":"API reference","title":"ReducedBasis.shift","text":"shift(grid::RegularGrid{D,N}, μ_shift; stay_in_bounds=false) where {D,N}\n\nShift a regular grid by a shift vector μ_shift. If stay_in_bounds=true, the shifted grid will stay in the convex hull of the unshifted grid. Note that the shift vector elements cannot be larger than the grid.ranges steps.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.solve-Tuple{AffineDecomposition, Any, Any, FullDiagonalization}","page":"API reference","title":"ReducedBasis.solve","text":"solve(H::AffineDecomposition, μ, Ψ₀, fd::FullDiagonalization)\n\nSolve Hamiltonian for lowest eigenvalues and eigenvectors at parameter point μ using  FullDiagonalization.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.solve-Tuple{AffineDecomposition, Any, Matrix, LOBPCG}","page":"API reference","title":"ReducedBasis.solve","text":"solve(H::AffineDecomposition, μ, Ψ₀::Matrix, lobpcg::LOBPCG)\nsolve(H::AffineDecomposition, μ, ::Nothing, lobpcg::LOBPCG)\n\nSolve using LOBPCG. If nothing is provided as an initial guess, an orthogonal random matrix will be used with lobpcg.n_target + lobpcg.n_ep_extra column vectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.solve-Tuple{AffineDecomposition, Any, Vector{ITensors.MPS}, DMRG}","page":"API reference","title":"ReducedBasis.solve","text":"solve(H::AffineDecomposition, μ, Ψ₀::Vector{MPS}, dm::DMRG)\nsolve(H::AffineDecomposition, μ, Ψ₀::MPS, dm::DMRG)\nsolve(H::AffineDecomposition, μ, ::Nothing, dm::DMRG)\n\nSolve using DMRG.\n\nThe length of the Ψ₀ vector determines the number of targeted states, given that dm.n_states > 1 and dm.tol_degeneracy > 0. When nothing is provided as an initial guess, dm.n_states random MPS are used.\n\n\n\n\n\n","category":"method"},{"location":"api/#ReducedBasis.solve-Tuple{AffineDecomposition, Matrix, Any, FullDiagonalization}","page":"API reference","title":"ReducedBasis.solve","text":"solve(h::AffineDecomposition, b::Matrix, μ, fd::FullDiagonalization)\n\nSolve the generalized eigenvalue problem h(bmmu) varphi(bmmu) = lambda(bmmu) b varphi(bmmu) at parameter point μ using FullDiagonalization.\n\n\n\n\n\n","category":"method"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"EditURL = \"https://github.com/mfherbst/ReducedBasis.jl/blob/master/examples/multi_ad.jl\"","category":"page"},{"location":"examples/multi_ad/#Affine-decompositions-with-multi-indices-and-additional-parameters","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"","category":"section"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"In this example, we want to explore the capabilities of the central AffineDecomposition type. To advance the previous examples where we covered the magnetization — a very simple observable that consists of only one affine term and a parameter-independent coefficient — we now turn to observables where the indices are multi-indices r = (r_1 dots r_d) and the coefficients can depend on additional parameters p, aside from the bmmu parameter points that are present in the Hamiltonian:","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"O(bmmu p) = sum_q=1^Q alpha_q(bmmu p) O_q","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"To stay within the realm of spin physics, we will consider the so-called spin structure factor","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"mathcalS(k) = frac1L sum_rr=1^L e^-i (r - r) k S^z_r S^z_rquad\nalpha_rr(k) = frace^-i (r - r) kL quad\nO_rr =  S^z_r S^z_r","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"with a wavevector parameter k, to discuss the implementation of a more complicated observable.","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"To provide a physical setup, we again use the XXZ chain from The reduced basis workflow:","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"using LinearAlgebra\nusing SparseArrays\nusing ReducedBasis\n\nσx = sparse([0.0 1.0; 1.0 0.0])\nσy = sparse([0.0 -im; im 0.0])\nσz = sparse([1.0 0.0; 0.0 -1.0])\n\nfunction to_global(op::M, L::Int, i::Int) where {M<:AbstractMatrix}\n    d = size(op, 1)\n    if i == 1\n        kron(op, M(I, d^(L - 1), d^(L - 1)))\n    elseif i == L\n        kron(M(I, d^(L - 1), d^(L - 1)), op)\n    else\n        kron(kron(M(I, d^(i - 1), d^(i - 1)), op), M(I, d^(L - i), d^(L - i)))\n    end\nend\n\nfunction xxz_chain(L)\n    H1 = 0.25 * sum(1:L-1) do i\n        to_global(σx, L, i) * to_global(σx, L, i + 1) +\n        to_global(σy, L, i) * to_global(σy, L, i + 1)\n    end\n    H2 = 0.25 * sum(1:L-1) do i\n        to_global(σz, L, i) * to_global(σz, L, i + 1)\n    end\n    H3 = 0.5  * sum(1:L) do i\n        to_global(σz, L, i)\n    end\n    AffineDecomposition([H1, H2, H3], μ -> [1.0, μ[1], -μ[2]])\nend;\nnothing #hide","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"Construct Hamiltonian for XXZ chain with 6 sites ...","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"L = 6\nH = xxz_chain(L);\nnothing #hide","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"... and generate a surrogate reduced basis using an exact diagonalization solver.","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"Δ  = range(-1.0, 2.5; length=40)\nhJ = range( 0.0, 3.5; length=40)\ngrid_train = RegularGrid(Δ, hJ)\ngreedy = Greedy(; estimator=Residual())\nlobpcg = LOBPCG(; tol_degeneracy=1e-4)\nqrcomp = QRCompress(; tol=1e-9)\nrbres = assemble(H, grid_train, greedy, lobpcg, qrcomp);\nnothing #hide","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"Now the task is to implement the double-sum in mathcalS, as well as the k-dependency in the coefficients. The double-sum can be encoded by putting all S^z_r S^z_r combinations into a L times L matrix:","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"terms = map(idx -> to_global(σz, L, first(idx.I)) * to_global(σz, L, last(idx.I)),\n            CartesianIndices((1:L, 1:L)));\nnothing #hide","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"Correspondingly, the coefficient function now has to map one k value to a matrix of coefficients of the same size as the terms matrix:","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"coefficients = k -> map(idx -> cis(-(first(idx.I) - last(idx.I)) * k) / L,\n                        CartesianIndices((1:L, 1:L)));\nnothing #hide","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"One feature of the structure factor that also shows up in many other affine decompositions with double-sums is that the term indices commute, i.e. O_rr = O_rr. In that case, only the upper triangular matrix has to be computed since B^dagger O_rr B = B^dagger O_rr B are the same in the compressed affine decomposition. So let's create the AffineDecomposition and compress, exploiting this symmetry using the symmetric_terms keyword argument:","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"SFspin    = AffineDecomposition(terms, coefficients)\nsfspin, _ = compress(SFspin, rbres.basis; symmetric_terms=true);\nnothing #hide","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"In the online evaluation of the structure factor, we then need to define some wavevector values and compute the structure factor at each of them. As usual, we first define a finer online grid of points and the matching online solver:","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"Δ_online    = range(first(Δ), last(Δ); length=100)\nhJ_online   = range(first(hJ), last(hJ); length=100)\ngrid_online = RegularGrid(Δ_online, hJ_online)\nfulldiag    = FullDiagonalization(lobpcg);\nnothing #hide","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"And then we map the grid points to the corresponding structure factor values for a set of different wavevectors:","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"using Statistics\nwavevectors = [0.0, π/4, π/2, π]\nsf = [zeros(size(grid_online)) for _ in 1:length(wavevectors)]\nfor (idx, μ) in pairs(grid_online)\n    _, φ_rb = solve(rbres.h, rbres.basis.metric, μ, fulldiag)\n    for (i, k) in enumerate(wavevectors)\n        sf[i][idx] = mean(u -> real(dot(u, sfspin(k), u)), eachcol(φ_rb))\n    end\nend","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"Here we again see the convenience of measuring observables in the online stage; adding more wavevector values does not significantly increase the computational cost, since it corresponds to a mere reevaluation of the coefficient functions and small vector-matrix products. Finally, let us see how the structure factor behaves for the different wavevector values:","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"using Plots\nkwargs = (; xlabel=raw\"$\\Delta$\", ylabel=raw\"$h/J$\", colorbar=true, leg=false)\nhms = []\nfor (i, q) in enumerate(wavevectors)\n    push!(hms, heatmap(grid_online.ranges[1], grid_online.ranges[2], sf[i]';\n                       title=\"\\$k = $(round(q/π; digits=3))\\\\pi\\$\", kwargs...))\nend\nplot(hms...)","category":"page"},{"location":"examples/multi_ad/","page":"Affine decompositions with multi-indices and additional parameters","title":"Affine decompositions with multi-indices and additional parameters","text":"It can be nicely seen that the spin structure factor indicates the ferromagnetic phase at k=0 and then moves through the magnetization plateaus until it reaches the antiferromagnetic plateau at k=pi.","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"EditURL = \"https://github.com/mfherbst/ReducedBasis.jl/blob/master/examples/xxz_ed.jl\"","category":"page"},{"location":"examples/xxz_ed/#The-reduced-basis-workflow","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"","category":"section"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"In this first example we want to provide an introduction to the reduced basis framework as applied to quantum spin systems. We want to see, from start to finish, how to set up a physical model, how to generate a surrogate basis and how to finally compute observable quantities. For that purpose, we cover the three basic steps of the reduced basis workflow:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Model setup: We first need to initialize the model Hamiltonian and the associated physical parameters.\nOffline phase: An assembly strategy and a truth solving method is chosen, with which we generate the reduced basis surrogate and we prepare observables for later measurement.\nOnline phase: Using the surrogate, we measure observables with reduced computational cost.","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Let us see, how to perform these steps using ReducedBasis.jl. As a first application, we will explore a canonical model from quantum spin physics, the one-dimensional spin-1/2 XXZ chain","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"H = sum_i=1^L-1 big S_i^x S_i+1^x + S_i^y S_i+1^y +\nDelta S_i^z S_i+1^z big - frachJ sum_i=1^L S_i^z ","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"To assemble the basis, a greedy algorithm will be used that tries to select as few snapshots as possible to generate a good surrogate. And to keep things simple, we will utilize exact diagonalization techniques to perform the eigenvalue solves to obtain snapshots at the desired parameter points. This means, H will be represented by a (sparse) matrix and the snapshots by vectors of Hilbert space dimension. Alternatively, one could e.g. provide H and its ground states in a tensor-based format allowing for low-rank approximations, which is reserved for a later example.","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"note: Simulation parameters\nIn the following we choose the simulation parameters in such a way as to keep the computational load small. We do this to be able to automatically run all example code during documentation compilation. As a result, the physical results are characteristic for small systems, i.e., they exhibit strong finite-size effects.","category":"page"},{"location":"examples/xxz_ed/#Model-setup","page":"The reduced basis workflow","title":"Model setup","text":"","category":"section"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Let us first set up the parametrized Hamiltonian matrix. In this specific example, we will need some utility functions to generate many-body spin Hamiltonians, but in other applications, possibly not connected to physics, the Hamiltonian setup will of course differ. However, all parametrized Hamiltonians will need to be cast into the form of an affine decomposition","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"H (bmmu) = sum_q=1^Q theta_q(bmmu) H_q ","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"The corresponding type in ReducedBasis is the AffineDecomposition which, as we will see, will account for both Hamiltonians and other observables that one would want to measure.","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Now coming to the XXZ chain, we want to implement the parametrized Hamiltonian matrix, for which we first need a way to create global many-body operators","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"S_i^gamma = (otimes^i-1 I) otimes frac12sigma^gamma otimes (otimes^N-i I)","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"which in this case are S=12 operators featuring the Pauli matrices sigma^gamma. So, let us first define the Pauli matrices as sparse matrices","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"using LinearAlgebra\nusing SparseArrays\nusing ReducedBasis\n\nσx = sparse([0.0 1.0; 1.0 0.0])\nσy = sparse([0.0 -im; im 0.0])\nσz = sparse([1.0 0.0; 0.0 -1.0]);\nnothing #hide","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"and create a function to make single-site operators global operators at site i for a many-body system of length L:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"function to_global(op::M, L::Int, i::Int) where {M<:AbstractMatrix}\n    d = size(op, 1)\n    if i == 1\n        kron(op, M(I, d^(L - 1), d^(L - 1)))\n    elseif i == L\n        kron(M(I, d^(L - 1), d^(L - 1)), op)\n    else\n        kron(kron(M(I, d^(i - 1), d^(i - 1)), op), M(I, d^(L - i), d^(L - i)))\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"To be able to create an AffineDecomposition, we first need to identify the terms H_q and the coefficient functions theta_q(bmmu). In our specific case, we can identify the parameter vector bmmu = (Delta hJ) and the associated coefficient function as bmtheta(bmmu) = (1 mu_1 -mu_2). Note that the first entry theta_1 = 1 since the first two summands of H do not have any non-trivial coefficients. Hence we arrive at the following Hamiltonian implementation:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"function xxz_chain(L)\n    H1 = 0.25 * sum(1:L-1) do i\n        to_global(σx, L, i) * to_global(σx, L, i + 1) +\n        to_global(σy, L, i) * to_global(σy, L, i + 1)\n    end\n    H2 = 0.25 * sum(1:L-1) do i\n        to_global(σz, L, i) * to_global(σz, L, i + 1)\n    end\n    H3 = 0.5  * sum(1:L) do i\n        to_global(σz, L, i)\n    end\n    AffineDecomposition([H1, H2, H3], μ -> [1.0, μ[1], -μ[2]])\nend;\nnothing #hide","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Using these functions, we initialize a small system of length L=6 with a matrix dimension of 2^6 = 64:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"L = 6\nH = xxz_chain(L);\nnothing #hide","category":"page"},{"location":"examples/xxz_ed/#Offline-phase","page":"The reduced basis workflow","title":"Offline phase","text":"","category":"section"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Now we can proceed by assembling the reduced basis. To that end we first choose a solver to find the lowest eigenvectors of H, for which in this case we use the LOBPCG solver. Since the XXZ model as defined above harbors degenerate ground states at some parameter points, we need to choose the right solver settings to account for that. To obtain the ground state subspace, with different eigenvalues are being distinguished up some tolerance tol_degeneracy, we set:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"lobpcg = LOBPCG(; tol_degeneracy=1e-4);\nnothing #hide","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Next, we need to restrict our surrogate to a certain domain in the (Delta hJ) parameter space and define a discrete grid of points on that domain. This is achieved, for example, by defining a 2-dimensional regular grid of parameter points using RegularGrid:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Δ = range(-1.0, 2.5; length=40)\nhJ = range(0.0, 3.5; length=40)\ngrid_train = RegularGrid(Δ, hJ);\nnothing #hide","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"For reasons of numerical stability, it is important orthogonalize the reduced basis during assembly (or use similar methods to keep the problem well-conditioned). Hence there are different protocols to extend a reduced basis by a new snapshot. An numerically efficient way to realize this is to use QR decomposition methods as implemented in QRCompress. Note that we choose a tolerance tol to discard snapshot vectors that do not significantly contribute to the basis:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"qrcomp = QRCompress(; tol=1e-9);\nnothing #hide","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"We lastly need to set the parameters for the greedy basis assembly by creating a Greedy object. This includes choosing an error estimate, as well as an error tolerance below which we stop the basis assembly:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"greedy = Greedy(; estimator=Residual(), tol=1e-3);\nnothing #hide","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"With that, we gathered all elements to be able generate the reduced basis:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"rbres = assemble(H, grid_train, greedy, lobpcg, qrcomp);\nnothing #hide","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"To finish up the offline phase, we want to define an observable, again as an AffineDecomposition and then compress it, to be able to measure it efficiently in the online stage. We will use the magnetization M = 2L^-1 sum_i=1^L S_i^z that serves as a so-called order parameter to distinguish different phases of the system in the parameter space. Conveniently, the magnetization already is contained in the third term of H:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"M    = AffineDecomposition([H.terms[3]], [2 / L])\nm, _ = compress(M, rbres.basis);\nnothing #hide","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Note that the compression again produces an AffineDecomposition which now contains only the low-dimensional matrices that operate in reduced basis space. In addition to the compressed observable, compress also returns a second decomposition for analysis purposes, which we will not cover in this example and hence did not assign. Since the coefficient 2L^-1 is actually parameter-independent, we can just construct m without passing any parameter point to obtain the constant reduced magnetization matrix:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"m_reduced = m();\nnothing #hide","category":"page"},{"location":"examples/xxz_ed/#Online-phase","page":"The reduced basis workflow","title":"Online phase","text":"","category":"section"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Having assembled a reduced basis surrogate, we now want to scan the parameter domain by measuring observables, in particular the magnetization from above. Fortunately, we have finished all Hilbert-space-dimension dependent steps and only operate in the low dimensional reduced basis space. This allows us to now compute observables on a much finer grid:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Δ_online = range(first(Δ), last(Δ); length=100)\nhJ_online = range(first(hJ), last(hJ); length=100)\ngrid_online = RegularGrid(Δ_online, hJ_online);\nnothing #hide","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Instead of solving for the ground states of H, we solve for the lowest eigenvectors of the reduced Hamiltonian in the online phase. Again, we need a solver, which in this case is FullDiagonalization, i.e. a wrapper around LinearAlgebra.eigen. To use degeneracy settings that match lobpcg from above, we can use the matching constructor:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"fulldiag = FullDiagonalization(lobpcg);\nnothing #hide","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"To compute expectation values on all online grid points — which we mean by \"scanning\" the parameter domain — it is convenient to use a map:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"using Statistics\nmagnetization = map(grid_online) do μ\n    _, φ_rb = solve(rbres.h, rbres.basis.metric, μ, fulldiag)\n    mean(u -> abs(dot(u, m_reduced, u)), eachcol(φ_rb))\nend;\nnothing #hide","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"Finally, we can take a look at the results. Note that, to plot a magnetization heatmap, we need to pass the transposed matrix magnetization', in order to use the rows as the x-axis. In addition to the magnetization, let us also plot the parameter points at which we performed truth solves in the offline stage:","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"using Plots\nhm = heatmap(grid_online.ranges[1], grid_online.ranges[2], magnetization';\n             xlabel=raw\"$\\Delta$\", ylabel=raw\"$h/J$\", title=\"magnetization\",\n             colorbar=true, clims=(0.0, 1.0), leg=false)\nparams = unique(rbres.basis.parameters)\nscatter!(hm, [μ[1] for μ in params], [μ[2] for μ in params];\n         markershape=:xcross, color=:springgreen, ms=3.0, msw=2.0)","category":"page"},{"location":"examples/xxz_ed/","page":"The reduced basis workflow","title":"The reduced basis workflow","text":"As expected from theory, we observe L2+1 discrete magnetization plateaus, as well as a ferromagnetic (M=1) and an antiferromagnetic phase (M=0) in the ground state phase diagram.","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"EditURL = \"https://github.com/mfherbst/ReducedBasis.jl/blob/master/examples/xxz_pod.jl\"","category":"page"},{"location":"examples/xxz_pod/#Basis-assembly-using-Proper-Orthogonal-Decomposition","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"","category":"section"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"In Greedy basis assembly using DMRG we have seen that we can customize the snapshot solvers as well as the compression methods during reduced basis assembly. What we want to demonstrate in this example is that we can also use different strategies for basis assembly altogether. In particular, we will show how to use the Proper Orthogonal Decomposition (POD) technique in the offline stage.","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"First we provide the setup already discussed in The reduced basis workflow:","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"using LinearAlgebra\nusing SparseArrays\nusing ReducedBasis\n\nσx = sparse([0.0 1.0; 1.0 0.0])\nσy = sparse([0.0 -im; im 0.0])\nσz = sparse([1.0 0.0; 0.0 -1.0])\n\nfunction to_global(op::M, L::Int, i::Int) where {M<:AbstractMatrix}\n    d = size(op, 1)\n    if i == 1\n        kron(op, M(I, d^(L - 1), d^(L - 1)))\n    elseif i == L\n        kron(M(I, d^(L - 1), d^(L - 1)), op)\n    else\n        kron(kron(M(I, d^(i - 1), d^(i - 1)), op), M(I, d^(L - i), d^(L - i)))\n    end\nend\n\nfunction xxz_chain(L)\n    H1 = 0.25 * sum(1:L-1) do i\n        to_global(σx, L, i) * to_global(σx, L, i + 1) +\n        to_global(σy, L, i) * to_global(σy, L, i + 1)\n    end\n    H2 = 0.25 * sum(1:L-1) do i\n        to_global(σz, L, i) * to_global(σz, L, i + 1)\n    end\n    H3 = 0.5  * sum(1:L) do i\n        to_global(σz, L, i)\n    end\n    AffineDecomposition([H1, H2, H3], μ -> [1.0, μ[1], -μ[2]])\nend;\nnothing #hide","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"The conceptual difference between POD and the greedy assembly strategy is that with POD, a truth solve is performed at all parameter points in the selected grid, followed by a singular value decomposition of the snapshot matrix. In this way, we obtain an orthogonal basis by using the singular vectors as our reduced basis. While this procedure is less complex than the greedy strategy, it comes with the significantly increased cost of having to solve snapshots at all grid points. Nonetheless, it can be useful to e.g. obtain a reference reduced basis and to compare against a greedy basis.","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"So let us stay with the example of the XXZ spin chain and initialize the Hamiltonian as before (using the functions defined in the first example) and choose a grid as well as a solver method:","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"L = 6\nH = xxz_chain(L)\n\nΔ = range(-1.0, 2.5; length=20)\nhJ = range(0.0, 3.5; length=20)\ngrid_train = RegularGrid(Δ, hJ)\n\nlobpcg = LOBPCG(; tol_degeneracy=1e-4);\nnothing #hide","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"Notice that we now use a coarser 20 × 20 grid since we perform truth solves on all parameter points and want to keep the computational effort low. Moreover, we are restricted to exact diagonalization solvers, since we need to explicitly construct the snapshot matrix in order to be able to perform an SVD on it. To assemble using POD, we create a POD object where we specify the number of retained columns, i.e. singular vectors of the snapshot matrix:","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"pod = POD(; n_vectors=24);\nnothing #hide","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"We then call assemble using our parameters, including pod, which selects the POD assembly method:","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"rbres = assemble(H, grid_train, pod, lobpcg);\nnothing #hide","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"Since we do not compute any Hamiltonian compressions during POD, we need to compute them afterwards using the HamiltonianCache constructor (recall that h is needed in the online stage):","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"h_cache = HamiltonianCache(H, rbres.basis);\nnothing #hide","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"Again, we arrive at the online phase which is performed analogously to The reduced basis workflow.","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"M = AffineDecomposition([H.terms[3]], [2 / L])\nm, _ = compress(M, rbres.basis)\nm_reduced = m()\nΔ_online = range(first(Δ), last(Δ); length=100)\nhJ_online = range(first(hJ), last(hJ); length=100)\ngrid_online = RegularGrid(Δ_online, hJ_online)\nfulldiag = FullDiagonalization(lobpcg)\n\nusing Statistics\nmagnetization = map(grid_online) do μ\n    _, φ_rb = solve(h_cache.h, rbres.basis.metric, μ, fulldiag)\n    mean(u -> abs(dot(u, m_reduced, u)), eachcol(φ_rb))\nend;\nnothing #hide","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"With this we can again produce a magnetization diagram:","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"using Plots\nhm = heatmap(grid_online.ranges[1], grid_online.ranges[2], magnetization';\n             xlabel=raw\"$\\Delta$\", ylabel=raw\"$h/J$\", title=\"magnetization\",\n             colorbar=true, clims=(0.0, 1.0), leg=false)\nplot!(hm, grid_online.ranges[1], x -> 1 + x; lw=2, ls=:dash, legend=false, color=:green)","category":"page"},{"location":"examples/xxz_pod/","page":"Basis assembly using Proper Orthogonal Decomposition","title":"Basis assembly using Proper Orthogonal Decomposition","text":"The magnetization phase diagram is correctly reproduced, however this time without the parameter point markers being plotted. This is due to the fact that all points in grid_train have been solved and incorporated into the reduced basis according to the POD procedure. The number of retained singular vectors therefore does not correspond directly to snapshots at certain parameter points but to linear combinations of them.","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"EditURL = \"https://github.com/mfherbst/ReducedBasis.jl/blob/master/examples/xxz_dmrg.jl\"","category":"page"},{"location":"examples/xxz_dmrg/#Greedy-basis-assembly-using-DMRG","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"","category":"section"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"As a follow-up example, we now want to showcase how to compute a reduced basis by means of the density matrix renormalization group (DMRG). To that end, we utilize the ITensors.jl package which, among other things, efficiently implements DMRG. We will see that, while we need to adjust the way we set up the model Hamiltonian as well as our solver, most steps stay the same. Again, we treat the one-dimensional S=12 XXZ model from the previous example.","category":"page"},{"location":"examples/xxz_dmrg/#Hamiltonians-as-MPOs","page":"Greedy basis assembly using DMRG","title":"Hamiltonians as MPOs","text":"","category":"section"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"Let us begin by building the XXZ Hamiltonian. Instead of constructing explicit matrices from Kronecker products as we did before, we now use a tensor format called matrix product operators (MPOs) to represent the Hamiltonian.","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"note: Random seed\nIn order to make the automatically generated documentation examples that utilize ITensors and in particular random initial states consistent and deterministic, we initialize the random number generator by calling Random.seed!.","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"using ITensors\nusing ReducedBasis\nusing Random: seed!\nseed!(0);\nnothing #hide","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"To build the Hamiltonian terms as MPOs, we make use of the ITensors.OpSum() object that automatically produces an MPO from a string of operators. The affine MPO terms are then stored in an AffineDecomposition as ApproxMPOs which also include possible truncation keyword arguments:","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"function xxz_chain(sites::IndexSet; kwargs...)\n    xy_term   = OpSum()\n    zz_term   = OpSum()\n    magn_term = OpSum()\n    for i in 1:(length(sites) - 1)\n        xy_term   += \"Sx\", i, \"Sx\", i + 1\n        xy_term   += \"Sy\", i, \"Sy\", i + 1\n        zz_term   += \"Sz\", i, \"Sz\", i + 1\n        magn_term += \"Sz\", i\n    end\n    magn_term += \"Sz\", length(sites)  # Add last magnetization term\n    AffineDecomposition([ApproxMPO(MPO(xy_term, sites), xy_term; kwargs...),\n                         ApproxMPO(MPO(zz_term, sites), zz_term; kwargs...),\n                         ApproxMPO(MPO(magn_term, sites), magn_term; kwargs...)],\n                        μ -> [1.0, μ[1], -μ[2]])\nend;\nnothing #hide","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"So let us instantiate such an MPO Hamiltonian where we also specify a singular value cutoff, which is passed to the ApproxMPO objects:","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"L = 12\nsites = siteinds(\"S=1/2\", L)\nH = xxz_chain(sites; cutoff=1e-9);\nnothing #hide","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"Notice that we can now choose a bigger system size (which is still very small here), since the tensor format allows for efficient low rank approximations (hence the cutoff) that buy us a substantial performance advantage when going to larger systems.","category":"page"},{"location":"examples/xxz_dmrg/#Using-the-[DMRG](@ref)-solver-for-obtaining-snapshots","page":"Greedy basis assembly using DMRG","title":"Using the DMRG solver for obtaining snapshots","text":"","category":"section"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"Having created our Hamiltonian in MPO format, we now need a solver that is able to compute ground states from MPOs. The corresponding ground state will also be obtained in a tensor format, namely as a matrix product state (MPS). This is achieved by ITensors.dmrg which is wrapped in the DMRG solver type:","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"dm = DMRG(; sweeps=default_sweeps(; cutoff_max=1e-9),\n          observer=() -> DMRGObserver(; energy_tol=1e-9));\nnothing #hide","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"For each solve a new ITensors.DMRGObserver object is created that converges the DMRG iteration up the specified energy_tol. The sweeps argument takes any ITensors.Sweeps object that controls the approximation settings with respect to the DMRG sweeps. While the implemented DMRG solver is capable of also solving degenerate ground states, we here opt for non-degenerate DMRG settings (see the n_states and tol_degeneracy keyword arguments in DMRG) which is the default behavior. (We do this due to a L+1-fold degeneracy on the parameter domain, where the degenerate DMRG solver can produce instable results for larger L.)","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"As discussed in the last example, we need a way to orthogonalize the reduced basis. Due to the MPS format that the snapshots will have, we cannot use QR decompositions anymore and resort to a different method, EigenDecomposition, featuring an eigenvalue decomposition of the snapshot overlap matrix that can drop insignificant snapshots that fall below a cutoff:","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"edcomp = EigenDecomposition(; cutoff=1e-7);\nnothing #hide","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"Now with different types for the Hamiltonian, the solver and the orthogonalizer, we call assemble using the greedy strategy and training grid from the last example. However, instead of specifying a tolerance for the maximal error estimate of our basis, we now set a maximal number of performed truth solves via n_truth_max:","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"Δ = range(-1.0, 2.5; length=40)\nhJ = range(0.0, 3.5; length=40)\ngrid_train = RegularGrid(Δ, hJ)\ngreedy = Greedy(; estimator=Residual(), n_truth_max=24)\n\nrbres = assemble(H, grid_train, greedy, dm, edcomp);\nnothing #hide","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"The returned basis now has snapshot vectors of ITensors.MPS type, which we have to keep in mind when we want to compress observables. That is to say, the observables have to be constructed as AffineDecompositions with ApproxMPO terms as we did for the Hamiltonian. Again, we want to compute the magnetization so that we can reuse the third term of H:","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"M    = AffineDecomposition([H.terms[3]], [2 / L])\nm, _ = compress(M, rbres.basis);\nnothing #hide","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"And at that point, we continue as before since we have arrived at the online phase where we only operate in the low-dimensional reduced basis space, agnostic of the snapshot solver method. We have to make sure, however, to choose matching degeneracy settings for the FullDiagonalization solver in the online phase:","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"fulldiag = FullDiagonalization(dm);\nnothing #hide","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"Then we can define an online grid and compute magnetization at all grid points, again constructing m at an arbitary parameter point since its coefficient is parameter-independent:","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"m_reduced = m()\nΔ_online = range(first(Δ), last(Δ); length=100)\nhJ_online = range(first(hJ), last(hJ); length=100)\ngrid_online = RegularGrid(Δ_online, hJ_online)\n\nusing Statistics\nmagnetization = map(grid_online) do μ\n    _, φ_rb = solve(rbres.h, rbres.basis.metric, μ, fulldiag)\n    mean(u -> abs(dot(u, m_reduced, u)), eachcol(φ_rb))\nend;\nnothing #hide","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"Plotting the magnetization on a heatmap, we arrive at the following result:","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"using Plots\nhm = heatmap(grid_online.ranges[1], grid_online.ranges[2], magnetization';\n             xlabel=raw\"$\\Delta$\", ylabel=raw\"$h/J$\", title=\"magnetization\",\n             colorbar=true, clims=(0.0, 1.0), leg=false)\nparams = unique(rbres.basis.parameters)\nscatter!(hm, [μ[1] for μ in params], [μ[2] for μ in params];\n         markershape=:xcross, color=:springgreen, ms=3.0, msw=2.0)","category":"page"},{"location":"examples/xxz_dmrg/","page":"Greedy basis assembly using DMRG","title":"Greedy basis assembly using DMRG","text":"We reproduce the ground state phase diagram, but this time with more magnetization plateaus (due to increased system size) and we see that the greedy algorithm chose different parameter points to solve using DMRG.","category":"page"},{"location":"#ReducedBasis.jl","page":"Home","title":"ReducedBasis.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ReducedBasis.jl is a Julia package that uses the reduced basis method (RBM) to accelerate the solution of a parametrized eigenvalue problems across the parameter domain.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the RBM approach, a surrogate model is assembled by projecting the full problem onto a basis consisting of only a few tens of parameter snapshots. The package focuses on a greedy strategy that selects snapshots by maximally reducing the estimated error with each additional snapshot. Once the RBM surrogate is assembled, physical observables can be computed for any parameter value with only a modest complexity, which scales independently from the dimension of the initial eigenvalue problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, the motivating application resides in quantum spin systems, following recent developments of RBM approaches in quantum many-body physics. Nonetheless ReducedBasis is intended to be generally applicable to parametrized eigenvalue problems with a low-dimensional parameter space. Key steps of the RBM procedure, such as the snapshot solving method, error estimates or the assembly strategy, can therefore be easily customized. Moreover, the package integrates with ITensors.jl that allows the use of tensor network methods, in particular the density matrix renormalization group using matrix product states.","category":"page"}]
}
