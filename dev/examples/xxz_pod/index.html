<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basis assembly using Proper Orthogonal Decomposition · ReducedBasis.jl</title><meta name="title" content="Basis assembly using Proper Orthogonal Decomposition · ReducedBasis.jl"/><meta property="og:title" content="Basis assembly using Proper Orthogonal Decomposition · ReducedBasis.jl"/><meta property="twitter:title" content="Basis assembly using Proper Orthogonal Decomposition · ReducedBasis.jl"/><meta name="description" content="Documentation for ReducedBasis.jl."/><meta property="og:description" content="Documentation for ReducedBasis.jl."/><meta property="twitter:description" content="Documentation for ReducedBasis.jl."/><meta property="og:url" content="https://mfherbst.github.io/ReducedBasis.jl/examples/xxz_pod/"/><meta property="twitter:url" content="https://mfherbst.github.io/ReducedBasis.jl/examples/xxz_pod/"/><link rel="canonical" href="https://mfherbst.github.io/ReducedBasis.jl/examples/xxz_pod/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ReducedBasis.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../xxz_ed/">The reduced basis workflow</a></li><li><a class="tocitem" href="../xxz_dmrg/">Greedy basis assembly using DMRG</a></li><li class="is-active"><a class="tocitem" href>Basis assembly using Proper Orthogonal Decomposition</a></li><li><a class="tocitem" href="../multi_ad/">Affine decompositions with multi-indices and additional parameters</a></li><li><a class="tocitem" href="../basis_analysis/">Analyzing and modifying a reduced basis after assembly</a></li></ul></li><li><a class="tocitem" href="../../api/">API reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Basis assembly using Proper Orthogonal Decomposition</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basis assembly using Proper Orthogonal Decomposition</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mfherbst/ReducedBasis.jl/blob/master/examples/xxz_pod.jl#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Basis-assembly-using-Proper-Orthogonal-Decomposition"><a class="docs-heading-anchor" href="#Basis-assembly-using-Proper-Orthogonal-Decomposition">Basis assembly using Proper Orthogonal Decomposition</a><a id="Basis-assembly-using-Proper-Orthogonal-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Basis-assembly-using-Proper-Orthogonal-Decomposition" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/mfherbst/ReducedBasis.jl/gh-pages?filepath=dev/examples/xxz_pod.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/mfherbst/ReducedBasis.jl/blob/gh-pages/dev/examples/xxz_pod.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In <a href="../xxz_dmrg/#Greedy-basis-assembly-using-DMRG">Greedy basis assembly using DMRG</a> we have seen that we can customize the snapshot solvers as well as the compression methods during RB assembly. What we want to demonstrate in this example is that we can also use different strategies for basis assembly altogether. In particular, we will show how to use the Proper Orthogonal Decomposition (<a href="../../api/#ReducedBasis.POD"><code>POD</code></a>) technique in the offline stage.</p><p>First we provide the setup already discussed in <a href="../xxz_ed/#The-reduced-basis-workflow">The reduced basis workflow</a>:</p><pre><code class="language-julia hljs">using LinearAlgebra
using SparseArrays
using ReducedBasis

σx = sparse([0.0 1.0; 1.0 0.0])
σy = sparse([0.0 -im; im 0.0])
σz = sparse([1.0 0.0; 0.0 -1.0])

function to_global(op::M, L::Int, i::Int) where {M&lt;:AbstractMatrix}
    d = size(op, 1)
    if i == 1
        kron(op, M(I, d^(L - 1), d^(L - 1)))
    elseif i == L
        kron(M(I, d^(L - 1), d^(L - 1)), op)
    else
        kron(kron(M(I, d^(i - 1), d^(i - 1)), op), M(I, d^(L - i), d^(L - i)))
    end
end

function xxz_chain(L)
    H1 = 0.25 * sum(1:L-1) do i
        to_global(σx, L, i) * to_global(σx, L, i + 1) +
        to_global(σy, L, i) * to_global(σy, L, i + 1)
    end
    H2 = 0.25 * sum(1:L-1) do i
        to_global(σz, L, i) * to_global(σz, L, i + 1)
    end
    H3 = 0.5  * sum(1:L) do i
        to_global(σz, L, i)
    end
    AffineDecomposition([H1, H2, H3], μ -&gt; [1.0, μ[1], -μ[2]])
end;</code></pre><p>The conceptual difference between POD and the greedy assembly strategy is that with POD, a truth solve is performed at all parameter points in the selected training grid, followed by a singular value decomposition of the snapshot matrix. In this way, we obtain an orthogonal basis by using the singular vectors as our RB. While this procedure is less complex than the greedy strategy, it comes with the significantly increased cost of having to solve snapshots at all grid points. Nonetheless, it can be useful, e.g., to obtain a reference RB and to compare against a greedy basis.</p><p>So let us stay with the example of the XXZ spin chain and initialize the Hamiltonian as before (using the functions defined in the first example) and choose a grid as well as a solver method:</p><pre><code class="language-julia hljs">L = 6
H = xxz_chain(L)

Δ = range(-1.0, 2.5; length=20)
hJ = range(0.0, 3.5; length=20)
grid_train = RegularGrid(Δ, hJ)

lobpcg = LOBPCG(; tol_degeneracy=1e-4);</code></pre><p>Notice that we now use a coarser 20 × 20 grid since we perform truth solves on all parameter points and want to keep the computational effort low. Moreover, we are restricted to exact diagonalization solvers, since we need to explicitly construct the snapshot matrix in order to be able to perform an SVD on it. To assemble using POD, we create a <a href="../../api/#ReducedBasis.POD"><code>POD</code></a> object where we specify the number of retained columns, i.e., singular vectors of the snapshot matrix:</p><pre><code class="language-julia hljs">pod = POD(; n_vectors=24);</code></pre><p>We then call <a href="../../api/#ReducedBasis.assemble-Tuple{AffineDecomposition, Any, POD, Any}"><code>assemble</code></a> using our parameters, including <code>pod</code>, which selects the POD assembly method:</p><pre><code class="language-julia hljs">rbres = assemble(H, grid_train, pod, lobpcg);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32">Truth solving on (20, 20) grid...   3%|▌                 |  ETA: 0:00:04</span><span class="sgr32">Truth solving on (20, 20) grid...   6%|█▏                |  ETA: 0:00:03</span><span class="sgr32">Truth solving on (20, 20) grid...  10%|█▊                |  ETA: 0:00:03</span><span class="sgr32">Truth solving on (20, 20) grid...  13%|██▍               |  ETA: 0:00:03</span><span class="sgr32">Truth solving on (20, 20) grid...  16%|███               |  ETA: 0:00:03</span><span class="sgr32">Truth solving on (20, 20) grid...  20%|███▌              |  ETA: 0:00:03</span><span class="sgr32">Truth solving on (20, 20) grid...  23%|████▏             |  ETA: 0:00:03</span><span class="sgr32">Truth solving on (20, 20) grid...  26%|████▋             |  ETA: 0:00:03</span><span class="sgr32">Truth solving on (20, 20) grid...  29%|█████▏            |  ETA: 0:00:02</span><span class="sgr32">Truth solving on (20, 20) grid...  32%|█████▊            |  ETA: 0:00:02</span><span class="sgr32">Truth solving on (20, 20) grid...  34%|██████▎           |  ETA: 0:00:02</span><span class="sgr32">Truth solving on (20, 20) grid...  38%|██████▊           |  ETA: 0:00:02</span><span class="sgr32">Truth solving on (20, 20) grid...  40%|███████▎          |  ETA: 0:00:02</span><span class="sgr32">Truth solving on (20, 20) grid...  43%|███████▊          |  ETA: 0:00:02</span><span class="sgr32">Truth solving on (20, 20) grid...  46%|████████▎         |  ETA: 0:00:02</span><span class="sgr32">Truth solving on (20, 20) grid...  49%|████████▊         |  ETA: 0:00:02</span><span class="sgr32">Truth solving on (20, 20) grid...  52%|█████████▍        |  ETA: 0:00:02</span><span class="sgr32">Truth solving on (20, 20) grid...  54%|█████████▊        |  ETA: 0:00:02</span><span class="sgr32">Truth solving on (20, 20) grid...  58%|██████████▍       |  ETA: 0:00:02</span><span class="sgr32">Truth solving on (20, 20) grid...  60%|██████████▉       |  ETA: 0:00:01</span><span class="sgr32">Truth solving on (20, 20) grid...  63%|███████████▍      |  ETA: 0:00:01</span><span class="sgr32">Truth solving on (20, 20) grid...  66%|███████████▉      |  ETA: 0:00:01</span><span class="sgr32">Truth solving on (20, 20) grid...  68%|████████████▍     |  ETA: 0:00:01</span><span class="sgr32">Truth solving on (20, 20) grid...  71%|████████████▉     |  ETA: 0:00:01</span><span class="sgr32">Truth solving on (20, 20) grid...  74%|█████████████▍    |  ETA: 0:00:01</span><span class="sgr32">Truth solving on (20, 20) grid...  77%|█████████████▉    |  ETA: 0:00:01</span><span class="sgr32">Truth solving on (20, 20) grid...  80%|██████████████▎   |  ETA: 0:00:01</span><span class="sgr32">Truth solving on (20, 20) grid...  82%|██████████████▉   |  ETA: 0:00:01</span><span class="sgr32">Truth solving on (20, 20) grid...  85%|███████████████▎  |  ETA: 0:00:01</span><span class="sgr32">Truth solving on (20, 20) grid...  88%|███████████████▉  |  ETA: 0:00:00</span><span class="sgr32">Truth solving on (20, 20) grid...  91%|████████████████▍ |  ETA: 0:00:00</span><span class="sgr32">Truth solving on (20, 20) grid...  94%|████████████████▉ |  ETA: 0:00:00</span><span class="sgr32">Truth solving on (20, 20) grid...  96%|█████████████████▍|  ETA: 0:00:00</span><span class="sgr32">Truth solving on (20, 20) grid...  99%|█████████████████▉|  ETA: 0:00:00</span><span class="sgr32">Truth solving on (20, 20) grid... 100%|██████████████████| Time: 0:00:03</span></code></pre><p>Since we do not compute any Hamiltonian compressions during POD, we need to compute them afterwards using the <a href="../../api/#ReducedBasis.HamiltonianCache"><code>HamiltonianCache</code></a> constructor (recall that <code>h</code> is needed in the online stage):</p><pre><code class="language-julia hljs">h_cache = HamiltonianCache(H, rbres.basis);</code></pre><p>Again, we arrive at the online phase which is performed analogously to <a href="../xxz_ed/#The-reduced-basis-workflow">The reduced basis workflow</a>.</p><pre><code class="language-julia hljs">M = AffineDecomposition([H.terms[3]], [2 / L])
m, _ = compress(M, rbres.basis)
m_reduced = m()
Δ_online = range(first(Δ), last(Δ); length=100)
hJ_online = range(first(hJ), last(hJ); length=100)
grid_online = RegularGrid(Δ_online, hJ_online)
fulldiag = FullDiagonalization(lobpcg)

using Statistics
magnetization = map(grid_online) do μ
    _, φ_rb = solve(h_cache.h, rbres.basis.metric, μ, fulldiag)
    mean(u -&gt; abs(dot(u, m_reduced, u)), eachcol(φ_rb))
end;</code></pre><p>With this we can again produce a magnetization diagram:</p><pre><code class="language-julia hljs">using Plots
hm = heatmap(grid_online.ranges[1], grid_online.ranges[2], magnetization&#39;;
             xlabel=raw&quot;$\Delta$&quot;, ylabel=raw&quot;$h/J$&quot;, title=&quot;magnetization&quot;,
             colorbar=true, clims=(0.0, 1.0), leg=false)
plot!(hm, grid_online.ranges[1], x -&gt; 1 + x; lw=2, ls=:dash, legend=false, color=:green)</code></pre><img src="1c209341.svg" alt="Example block output"/><p>The magnetization phase diagram is correctly reproduced, however this time without the parameter point markers being plotted. This is due to the fact that all points in <code>grid_train</code> have been solved and incorporated into the RB according to the POD procedure. The number of retained singular vectors therefore does not correspond directly to snapshots at certain parameter points but to linear combinations of them.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../xxz_dmrg/">« Greedy basis assembly using DMRG</a><a class="docs-footer-nextpage" href="../multi_ad/">Affine decompositions with multi-indices and additional parameters »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Friday 10 May 2024 17:22">Friday 10 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
