<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The reduced basis workflow · ReducedBasis.jl</title><meta name="title" content="The reduced basis workflow · ReducedBasis.jl"/><meta property="og:title" content="The reduced basis workflow · ReducedBasis.jl"/><meta property="twitter:title" content="The reduced basis workflow · ReducedBasis.jl"/><meta name="description" content="Documentation for ReducedBasis.jl."/><meta property="og:description" content="Documentation for ReducedBasis.jl."/><meta property="twitter:description" content="Documentation for ReducedBasis.jl."/><meta property="og:url" content="https://mfherbst.github.io/ReducedBasis.jl/examples/xxz_ed/"/><meta property="twitter:url" content="https://mfherbst.github.io/ReducedBasis.jl/examples/xxz_ed/"/><link rel="canonical" href="https://mfherbst.github.io/ReducedBasis.jl/examples/xxz_ed/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ReducedBasis.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>The reduced basis workflow</a><ul class="internal"><li><a class="tocitem" href="#Model-setup"><span>Model setup</span></a></li><li><a class="tocitem" href="#Offline-phase"><span>Offline phase</span></a></li><li><a class="tocitem" href="#Online-phase"><span>Online phase</span></a></li></ul></li><li><a class="tocitem" href="../xxz_dmrg/">Greedy basis assembly using DMRG</a></li><li><a class="tocitem" href="../xxz_pod/">Basis assembly using Proper Orthogonal Decomposition</a></li><li><a class="tocitem" href="../multi_ad/">Affine decompositions with multi-indices and additional parameters</a></li><li><a class="tocitem" href="../basis_analysis/">Analyzing and modifying a reduced basis after assembly</a></li></ul></li><li><a class="tocitem" href="../../api/">API reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>The reduced basis workflow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The reduced basis workflow</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mfherbst/ReducedBasis.jl/blob/master/examples/xxz_ed.jl#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="The-reduced-basis-workflow"><a class="docs-heading-anchor" href="#The-reduced-basis-workflow">The reduced basis workflow</a><a id="The-reduced-basis-workflow-1"></a><a class="docs-heading-anchor-permalink" href="#The-reduced-basis-workflow" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/mfherbst/ReducedBasis.jl/gh-pages?filepath=dev/examples/xxz_ed.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/mfherbst/ReducedBasis.jl/blob/gh-pages/dev/examples/xxz_ed.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In this first example we want to provide an introduction to the RB framework as applied to quantum spin systems. We want to see, from start to finish, how to set up a physical model, how to generate a surrogate basis and how to finally compute observable quantities. For that purpose, we cover the three basic steps of the RB workflow:</p><ol><li>Model setup: We first need to initialize the model Hamiltonian and the associated physical parameters.</li><li>Offline phase: An assembly strategy and a truth solving method is chosen, with which we generate the RB surrogate and we prepare observables for later measurement.</li><li>Online phase: Using the surrogate, we measure observables with reduced computational cost.</li></ol><p>Let us see, how to perform these steps using ReducedBasis.jl. As a first application, we will explore a canonical model from quantum spin physics, the <em>one-dimensional spin-1/2 XXZ chain</em></p><p class="math-container">\[H = \sum_{i=1}^{L-1} \big[ S_i^x S_{i+1}^x + S_i^y S_{i+1}^y +
\Delta S_i^z S_{i+1}^z \big] - \frac{h}{J} \sum_{i=1}^L S_i^z .\]</p><p>To assemble the basis, a greedy algorithm will be used that tries to select as few snapshots as possible to generate a good surrogate. And to keep things simple, we will utilize exact diagonalization techniques to perform the eigenvalue solves to obtain snapshots at the desired parameter points. This means, <span>$H$</span> will be represented by a (sparse) matrix and the snapshots by vectors of Hilbert space dimension. Alternatively, one could, e.g., provide <span>$H$</span> and its ground states in a tensor-based format allowing for low-rank approximations, which is reserved for a later example.</p><div class="admonition is-info"><header class="admonition-header">Simulation parameters</header><div class="admonition-body"><p>In the following we choose the simulation parameters in such a way as to keep the computational load small. We do this to be able to automatically run all example code during documentation compilation. As a result, the physical results are characteristic for small systems, i.e., they exhibit strong finite-size effects.</p></div></div><h2 id="Model-setup"><a class="docs-heading-anchor" href="#Model-setup">Model setup</a><a id="Model-setup-1"></a><a class="docs-heading-anchor-permalink" href="#Model-setup" title="Permalink"></a></h2><p>Let us first set up the parametrized Hamiltonian matrix. In this specific example, we will need some utility functions to generate many-body spin Hamiltonians, but in other applications, possibly not connected to physics, the Hamiltonian setup will of course differ. However, all parametrized Hamiltonians will need to be cast into the form of an <em>affine decomposition</em></p><p class="math-container">\[H (\bm{\mu}) = \sum_{q=1}^Q \theta_q(\bm{\mu})\, H_q .\]</p><p>The corresponding type in ReducedBasis is the <a href="../../api/#ReducedBasis.AffineDecomposition"><code>AffineDecomposition</code></a> which, as we will see, will account for both Hamiltonians and other observables that one would want to measure.</p><p>Now coming to the XXZ chain, we want to implement the parametrized Hamiltonian matrix, for which we first need a way to create global many-body operators</p><p class="math-container">\[S_i^\gamma = (\otimes^{i-1} I) \otimes \frac{1}{2}\sigma^\gamma \otimes (\otimes^{N-i} I),\]</p><p>which in this case are <span>$S=1/2$</span> operators featuring the <a href="https://en.wikipedia.org/wiki/Pauli_matrices">Pauli matrices</a> <span>$\sigma^\gamma$</span>. So, let us first define the Pauli matrices as sparse matrices</p><pre><code class="language-julia hljs">using LinearAlgebra
using SparseArrays
using ReducedBasis

σx = sparse([0.0 1.0; 1.0 0.0])
σy = sparse([0.0 -im; im 0.0])
σz = sparse([1.0 0.0; 0.0 -1.0]);</code></pre><p>and create a function to promote single-site operators to global operators at site <code>i</code> for a many-body system of length <code>L</code>:</p><pre><code class="language-julia hljs">function to_global(op::M, L::Int, i::Int) where {M&lt;:AbstractMatrix}
    d = size(op, 1)
    if i == 1
        kron(op, M(I, d^(L - 1), d^(L - 1)))
    elseif i == L
        kron(M(I, d^(L - 1), d^(L - 1)), op)
    else
        kron(kron(M(I, d^(i - 1), d^(i - 1)), op), M(I, d^(L - i), d^(L - i)))
    end
end;</code></pre><p>To be able to create an <a href="../../api/#ReducedBasis.AffineDecomposition"><code>AffineDecomposition</code></a>, we first need to identify the terms <span>$H_q$</span> and the coefficient functions <span>$\theta_q(\bm{\mu})$</span>. In our specific case, we can identify the parameter vector <span>$\bm{\mu} = (\Delta, h/J)$</span> and the associated coefficient function as <span>$\bm{\theta}(\bm{\mu}) = (1, \mu_1, -\mu_2)$</span>. Note that the first entry <span>$\theta_1 = 1$</span> since the first two summands of <span>$H$</span> do not have any non-trivial coefficients. Hence we arrive at the following Hamiltonian implementation:</p><pre><code class="language-julia hljs">function xxz_chain(L)
    H1 = 0.25 * sum(1:L-1) do i
        to_global(σx, L, i) * to_global(σx, L, i + 1) +
        to_global(σy, L, i) * to_global(σy, L, i + 1)
    end
    H2 = 0.25 * sum(1:L-1) do i
        to_global(σz, L, i) * to_global(σz, L, i + 1)
    end
    H3 = 0.5  * sum(1:L) do i
        to_global(σz, L, i)
    end
    AffineDecomposition([H1, H2, H3], μ -&gt; [1.0, μ[1], -μ[2]])
end;</code></pre><p>Using these functions, we initialize a small system of length <span>$L=6$</span> with a matrix dimension of <span>$2^6 = 64$</span>:</p><pre><code class="language-julia hljs">L = 6
H = xxz_chain(L);</code></pre><h2 id="Offline-phase"><a class="docs-heading-anchor" href="#Offline-phase">Offline phase</a><a id="Offline-phase-1"></a><a class="docs-heading-anchor-permalink" href="#Offline-phase" title="Permalink"></a></h2><p>Now we can proceed by assembling the reduced basis. To that end we first choose a solver to find the lowest eigenvectors of <span>$H$</span>, for which in this case we use the <a href="../../api/#ReducedBasis.LOBPCG"><code>LOBPCG</code></a> solver. Since the XXZ model as defined above harbors degenerate ground states at some parameter points, we need to choose the right solver settings to account for that. To obtain the ground-state subspace, with different eigenvalues are being distinguished up to some tolerance <code>tol_degeneracy</code>, we set:</p><pre><code class="language-julia hljs">lobpcg = LOBPCG(; tol_degeneracy=1e-4);</code></pre><p>Next, we need to restrict our surrogate to a certain domain in the <span>$(\Delta, h/J)$</span> parameter space and define a discrete grid of points on that domain. This is achieved, for example, by defining a 2-dimensional regular grid of parameter points using <a href="../../api/#ReducedBasis.RegularGrid"><code>RegularGrid</code></a>:</p><pre><code class="language-julia hljs">Δ = range(-1.0, 2.5; length=40)
hJ = range(0.0, 3.5; length=40)
grid_train = RegularGrid(Δ, hJ);</code></pre><div class="admonition is-info"><header class="admonition-header">Choice of training grid</header><div class="admonition-body"><p>While in many cases the choice of the training grid does not have a large impact on the greedy assembly, as long as the resolution is high enough to resolve the physical features underlying the Hamiltonian, there are some cases where special care is required. In particular, the initial parameter point that is used to assemble the basis (see <a href="../../api/#ReducedBasis.assemble-Tuple{AffineDecomposition, Any, POD, Any}"><code>assemble</code></a>) can make crucial differences, when the Hamiltonian possesses conserved quantities. For instance, for the XXZ chain, we need to choose <span>$\bm\mu = (-1,0)$</span> since <span>$H$</span> has plateaus of conserved magnetization (see below), and any other choice would lock the basis to one particular magnetization sector. As this is the first parameter point in <code>grid_train</code> anyway, we do not need to further specify the initial parameter point below.</p></div></div><p>For reasons of numerical stability, it is important orthogonalize the RB during assembly (or use similar methods to keep the problem well-conditioned). Hence there are different protocols to extend a RB by a new snapshot. A numerically efficient way to realize this is to use QR decomposition methods as implemented in <a href="../../api/#ReducedBasis.QRCompress"><code>QRCompress</code></a>. Note that we choose a tolerance <code>tol</code> to discard snapshot vectors that do not significantly contribute to the basis:</p><pre><code class="language-julia hljs">qrcomp = QRCompress(; tol=1e-9);</code></pre><p>We lastly need to set the parameters for the greedy basis assembly by creating a <a href="../../api/#ReducedBasis.Greedy"><code>Greedy</code></a> object. This includes choosing an error estimate, as well as an error tolerance below which we use to stop the basis assembly:</p><pre><code class="language-julia hljs">greedy = Greedy(; estimator=Residual(), tol=1e-3);</code></pre><p>With that, we gathered all elements to be able generate the reduced basis:</p><pre><code class="language-julia hljs">rbres = assemble(H, grid_train, greedy, lobpcg, qrcomp);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">n      max. err    ‖BᵀB-I‖     time      μ
------------------------------------------------------------
1      NaN         5.68e-15     227ms    [-1.0, 0.0]
2      2.33        5.7e-15      240ms    [2.231, 0.538]
3      0.946       5.8e-15      106ms    [0.795, 0.897]
4      0.508       5.91e-15    51.4ms    [1.154, 1.795]
5      0.472       6.21e-15     100ms    [2.5, 1.077]
6      0.385       6.51e-15     101ms    [0.346, 0.179]
7      0.0727      1.23e-14    79.6ms    [-0.551, 0.0]
8      0.0554      1.93e-14    89.2ms    [-0.462, 0.269]
9      0.0163      9.5e-14     96.8ms    [1.423, 0.538]
10     0.00522     1.61e-13     111ms    [-0.372, 0.449]
11     0.004       3.05e-13     120ms    [1.692, 1.346]
12     0.00151     4.61e-13     139ms    [-0.821, 0.0]
13     0.00039     1.08e-12     158ms    [-0.821, 0.09]
reached residual target</code></pre><p>To finish up the offline phase, we want to define an observable, again as an <a href="../../api/#ReducedBasis.AffineDecomposition"><code>AffineDecomposition</code></a> and then compress it, to be able to measure it efficiently in the online stage. We will use the <em>magnetization</em> <span>$M = 2L^{-1} \sum_{i=1}^L S_i^z$</span> that serves as a so-called order parameter to distinguish different phases of the system in the parameter space. Conveniently, the magnetization already is contained in the third term of <span>$H$</span>:</p><pre><code class="language-julia hljs">M    = AffineDecomposition([H.terms[3]], [2 / L])
m, _ = compress(M, rbres.basis);</code></pre><p>Note that the compression again produces an <a href="../../api/#ReducedBasis.AffineDecomposition"><code>AffineDecomposition</code></a> which now contains only the low-dimensional matrices that operate in RB space. In addition to the compressed observable, <a href="../../api/#ReducedBasis.compress-Tuple{AbstractMatrix, AbstractVector{&lt;:AbstractVector}}"><code>compress</code></a> also returns a second decomposition for analysis purposes, which we will not cover in this example and hence did not assign. Since the coefficient <span>$2L^{-1}$</span> is actually parameter-independent, we can just construct <code>m</code> without passing any parameter point to obtain the constant reduced magnetization matrix:</p><pre><code class="language-julia hljs">m_reduced = m();</code></pre><h2 id="Online-phase"><a class="docs-heading-anchor" href="#Online-phase">Online phase</a><a id="Online-phase-1"></a><a class="docs-heading-anchor-permalink" href="#Online-phase" title="Permalink"></a></h2><p>Having assembled a RB surrogate, we now want to scan the parameter domain by measuring observables, in particular the magnetization from above. Fortunately, we have finished all Hilbert-space-dimension dependent steps and only operate in the low dimensional RB space. This allows us to now compute observables on a much finer grid:</p><pre><code class="language-julia hljs">Δ_online = range(first(Δ), last(Δ); length=100)
hJ_online = range(first(hJ), last(hJ); length=100)
grid_online = RegularGrid(Δ_online, hJ_online);</code></pre><p>Instead of solving for the ground states of <span>$H$</span>, we solve for the lowest eigenvectors of the reduced Hamiltonian in the online phase. Again, we need a solver, which in this case is <a href="../../api/#ReducedBasis.FullDiagonalization"><code>FullDiagonalization</code></a>, i.e., a wrapper around <code>LinearAlgebra.eigen</code>. To use degeneracy settings that match <code>lobpcg</code> from above, we can use the matching constructor:</p><pre><code class="language-julia hljs">fulldiag = FullDiagonalization(lobpcg);</code></pre><p>To compute expectation values on all online grid points — which we mean by &quot;scanning&quot; the parameter domain — it is convenient to use a <code>map</code>:</p><pre><code class="language-julia hljs">using Statistics
magnetization = map(grid_online) do μ
    _, φ_rb = solve(rbres.h, rbres.basis.metric, μ, fulldiag)
    mean(u -&gt; abs(dot(u, m_reduced, u)), eachcol(φ_rb))
end;</code></pre><p>Finally, we can take a look at the results. Note that, to plot a magnetization heatmap, we need to pass the transposed matrix <code>magnetization&#39;</code>, in order to use the rows as the x-axis. In addition to the magnetization, let us also plot the parameter points at which we performed truth solves in the offline stage:</p><pre><code class="language-julia hljs">using Plots
hm = heatmap(grid_online.ranges[1], grid_online.ranges[2], magnetization&#39;;
             xlabel=raw&quot;$\Delta$&quot;, ylabel=raw&quot;$h/J$&quot;, title=&quot;magnetization&quot;,
             colorbar=true, clims=(0.0, 1.0), leg=false)
params = unique(rbres.basis.parameters)
scatter!(hm, [μ[1] for μ in params], [μ[2] for μ in params];
         markershape=:xcross, color=:springgreen, ms=3.0, msw=2.0)</code></pre><img src="a6157397.svg" alt="Example block output"/><p>As expected from theory, we observe <span>$L/2+1$</span> discrete magnetization plateaus, as well as a ferromagnetic (<span>$M=1$</span>) and an antiferromagnetic phase (<span>$M=0$</span>) in the ground state phase diagram.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../xxz_dmrg/">Greedy basis assembly using DMRG »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Friday 10 May 2024 17:22">Friday 10 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
