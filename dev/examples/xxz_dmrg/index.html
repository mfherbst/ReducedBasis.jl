<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Greedy basis assembly using DMRG · ReducedBasis.jl</title><meta name="title" content="Greedy basis assembly using DMRG · ReducedBasis.jl"/><meta property="og:title" content="Greedy basis assembly using DMRG · ReducedBasis.jl"/><meta property="twitter:title" content="Greedy basis assembly using DMRG · ReducedBasis.jl"/><meta name="description" content="Documentation for ReducedBasis.jl."/><meta property="og:description" content="Documentation for ReducedBasis.jl."/><meta property="twitter:description" content="Documentation for ReducedBasis.jl."/><meta property="og:url" content="https://mfherbst.github.io/ReducedBasis.jl/examples/xxz_dmrg/"/><meta property="twitter:url" content="https://mfherbst.github.io/ReducedBasis.jl/examples/xxz_dmrg/"/><link rel="canonical" href="https://mfherbst.github.io/ReducedBasis.jl/examples/xxz_dmrg/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ReducedBasis.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../xxz_ed/">The reduced basis workflow</a></li><li class="is-active"><a class="tocitem" href>Greedy basis assembly using DMRG</a><ul class="internal"><li><a class="tocitem" href="#Hamiltonians-as-MPOs"><span>Hamiltonians as <code>MPO</code>s</span></a></li><li><a class="tocitem" href="#Using-the-[DMRG](@ref)-solver-for-obtaining-snapshots"><span>Using the <code>DMRG</code> solver for obtaining snapshots</span></a></li></ul></li><li><a class="tocitem" href="../xxz_pod/">Basis assembly using Proper Orthogonal Decomposition</a></li><li><a class="tocitem" href="../multi_ad/">Affine decompositions with multi-indices and additional parameters</a></li><li><a class="tocitem" href="../basis_analysis/">Analyzing and modifying a reduced basis after assembly</a></li></ul></li><li><a class="tocitem" href="../../api/">API reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Greedy basis assembly using DMRG</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Greedy basis assembly using DMRG</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mfherbst/ReducedBasis.jl/blob/master/examples/xxz_dmrg.jl#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Greedy-basis-assembly-using-DMRG"><a class="docs-heading-anchor" href="#Greedy-basis-assembly-using-DMRG">Greedy basis assembly using DMRG</a><a id="Greedy-basis-assembly-using-DMRG-1"></a><a class="docs-heading-anchor-permalink" href="#Greedy-basis-assembly-using-DMRG" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/mfherbst/ReducedBasis.jl/gh-pages?filepath=dev/examples/xxz_dmrg.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/mfherbst/ReducedBasis.jl/blob/gh-pages/dev/examples/xxz_dmrg.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>As a follow-up example, we now want to showcase how to compute a reduced basis by means of the <a href="https://tensornetwork.org/mps/algorithms/dmrg/">density matrix renormalization group</a> (DMRG). To that end, we utilize the <a href="https://itensor.github.io/ITensors.jl/stable/">ITensors.jl</a> package which, among other things, efficiently implements DMRG. We will see that, while we need to adjust the way we set up the model Hamiltonian as well as our solver, most steps stay the same. Again, we treat the one-dimensional <span>$S=1/2$</span> XXZ model from the previous example.</p><h2 id="Hamiltonians-as-MPOs"><a class="docs-heading-anchor" href="#Hamiltonians-as-MPOs">Hamiltonians as <code>MPO</code>s</a><a id="Hamiltonians-as-MPOs-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonians-as-MPOs" title="Permalink"></a></h2><p>Let us begin by building the XXZ Hamiltonian. Instead of constructing explicit matrices from Kronecker products as we did before, we now use a tensor format called <em>matrix product operators</em> (MPOs) to represent the Hamiltonian.</p><div class="admonition is-info"><header class="admonition-header">Random seed</header><div class="admonition-body"><p>In order to make the automatically generated documentation examples that utilize <code>ITensors</code> and in particular random initial states consistent and deterministic, we initialize the random number generator by calling <code>Random.seed!</code>.</p></div></div><pre><code class="language-julia hljs">using ITensors
using ReducedBasis
using Random: seed!
seed!(0);</code></pre><p>To build the Hamiltonian terms as MPOs, we make use of the <code>ITensors.OpSum()</code> object that automatically produces a MPO from a string of operators. The affine MPO terms are then stored in an <a href="../../api/#ReducedBasis.AffineDecomposition"><code>AffineDecomposition</code></a> as <a href="../../api/#ReducedBasis.ApproxMPO"><code>ApproxMPO</code></a>s which also include possible truncation keyword arguments:</p><pre><code class="language-julia hljs">function xxz_chain(sites::IndexSet; kwargs...)
    xy_term   = OpSum()
    zz_term   = OpSum()
    magn_term = OpSum()
    for i in 1:(length(sites) - 1)
        xy_term   += &quot;Sx&quot;, i, &quot;Sx&quot;, i + 1
        xy_term   += &quot;Sy&quot;, i, &quot;Sy&quot;, i + 1
        zz_term   += &quot;Sz&quot;, i, &quot;Sz&quot;, i + 1
        magn_term += &quot;Sz&quot;, i
    end
    magn_term += &quot;Sz&quot;, length(sites)  # Add last magnetization term
    AffineDecomposition([ApproxMPO(MPO(xy_term, sites), xy_term; kwargs...),
                         ApproxMPO(MPO(zz_term, sites), zz_term; kwargs...),
                         ApproxMPO(MPO(magn_term, sites), magn_term; kwargs...)],
                        μ -&gt; [1.0, μ[1], -μ[2]])
end;</code></pre><p>So let us instantiate such a MPO Hamiltonian where we also specify a singular value <code>cutoff</code>, which is passed to the <a href="../../api/#ReducedBasis.ApproxMPO"><code>ApproxMPO</code></a> objects:</p><pre><code class="language-julia hljs">L = 12
sites = siteinds(&quot;S=1/2&quot;, L)
H = xxz_chain(sites; cutoff=1e-9);</code></pre><p>Notice that we can now choose a bigger system size (which is still very small here), since the tensor format allows for efficient low rank approximations (hence the <code>cutoff</code>) that buy us a substantial performance advantage when going to larger systems.</p><h2 id="Using-the-[DMRG](@ref)-solver-for-obtaining-snapshots"><a class="docs-heading-anchor" href="#Using-the-[DMRG](@ref)-solver-for-obtaining-snapshots">Using the <a href="../../api/#ReducedBasis.DMRG"><code>DMRG</code></a> solver for obtaining snapshots</a><a id="Using-the-[DMRG](@ref)-solver-for-obtaining-snapshots-1"></a><a class="docs-heading-anchor-permalink" href="#Using-the-[DMRG](@ref)-solver-for-obtaining-snapshots" title="Permalink"></a></h2><p>Having created our Hamiltonian in MPO format, we now need a solver that is able to compute ground states from MPOs. The corresponding ground state will also be obtained in a tensor format, namely as a <em>matrix product state</em> (MPS). This is achieved by <code>ITensors.dmrg</code> which is wrapped in the <a href="../../api/#ReducedBasis.DMRG"><code>DMRG</code></a> solver type:</p><pre><code class="language-julia hljs">dm = DMRG(; sweeps=default_sweeps(; cutoff_max=1e-9),
          observer=() -&gt; DMRGObserver(; energy_tol=1e-9));</code></pre><p>For each solve a new <code>ITensors.DMRGObserver</code> object is created that converges the DMRG iteration up the specified <code>energy_tol</code>. The sweeps argument takes any <code>ITensors.Sweeps</code> object that controls the approximation settings with respect to the DMRG sweeps. While the implemented DMRG solver is capable of also solving degenerate ground states, we here opt for non-degenerate DMRG settings (see the <code>n_states</code> and <code>tol_degeneracy</code> keyword arguments in <a href="../../api/#ReducedBasis.DMRG"><code>DMRG</code></a>) which is the default behavior. (We do this due to a <span>$L+1$</span>-fold degeneracy on the parameter domain, where the degenerate DMRG solver can produce instable results for larger <span>$L$</span>.)</p><p>As discussed in the last example, we need a way to orthogonalize the reduced basis. Due to the MPS format that the snapshots will have, we cannot use QR decompositions anymore and resort to a different method, <a href="../../api/#ReducedBasis.EigenDecomposition"><code>EigenDecomposition</code></a>, featuring an eigenvalue decomposition of the snapshot overlap matrix that can drop insignificant snapshots that fall below a cutoff:</p><pre><code class="language-julia hljs">edcomp = EigenDecomposition(; cutoff=1e-7);</code></pre><p>Now with different types for the Hamiltonian, the solver and the orthogonalizer, we call <code>assemble</code> using the <code>greedy</code> strategy and training grid from the last example. However, instead of specifying a tolerance for the maximal error estimate of our basis, we now set a maximal number of performed truth solves via <code>n_truth_max</code>:</p><pre><code class="language-julia hljs">Δ = range(-1.0, 2.5; length=40)
hJ = range(0.0, 3.5; length=40)
grid_train = RegularGrid(Δ, hJ)
greedy = Greedy(; estimator=Residual(), n_truth_max=24)

rbres = assemble(H, grid_train, greedy, dm, edcomp);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">n      max. err    ‖BᵀB-I‖     time      μ
------------------------------------------------------------
1      NaN         8.88e-16     430ms    [-1.0, 0.0]
2      6.3         2.29e-16     613ms    [2.5, 3.5]
3      3.36        3.91e-16     362ms    [2.5, 0.538]
4      1.52        1.74e-14     567ms    [-0.282, 0.09]
5      1.87        1.91e-13     228ms    [2.5, 2.513]
6      0.934       7.49e-15     216ms    [0.795, 0.0]
7      0.726       6.06e-15     218ms    [0.077, 0.718]
8      0.868       5.91e-15     212ms    [2.5, 3.141]
9      0.723       6.31e-15     223ms    [0.795, 0.538]
10     0.814       1.43e-14     242ms    [2.5, 0.897]
11     0.708       1.12e-14     214ms    [2.051, 2.423]
12     0.538       5.14e-14     247ms    [0.705, 0.897]
13     0.443       3.19e-14     313ms    [-0.103, 0.0]
14     0.274       3.78e-14     306ms    [-0.372, 0.269]
15     0.233       1.16e-13     782ms    [-0.91, 0.0]
16     0.229       8.77e-14     300ms    [-0.462, 0.449]
17     0.113       1.1e-13      336ms    [-0.641, 0.09]
18     0.103       1.44e-13     992ms    [-0.821, 0.09]
19     0.079       9.01e-13     418ms    [1.782, 0.359]
20     0.0748      8.76e-13     419ms    [-0.731, 0.09]
21     0.041       1.05e-11     440ms    [1.692, 1.256]
22     0.0393      2.46e-12     483ms    [-0.641, 0.0]
23     0.0269      3.72e-12     472ms    [0.526, 1.436]
24     0.0933      7.78e-12     478ms    [2.5, 3.41]</code></pre><p>The returned <code>basis</code> now has snapshot vectors of <code>ITensors.MPS</code> type, which we have to keep in mind when we want to compress observables. That is to say, the observables have to be constructed as <a href="../../api/#ReducedBasis.AffineDecomposition"><code>AffineDecomposition</code></a>s with <a href="../../api/#ReducedBasis.ApproxMPO"><code>ApproxMPO</code></a> terms as we did for the Hamiltonian. Again, we want to compute the magnetization so that we can reuse the third term of <code>H</code>:</p><pre><code class="language-julia hljs">M    = AffineDecomposition([H.terms[3]], [2 / L])
m, _ = compress(M, rbres.basis);</code></pre><p>And at that point, we continue as before since we have arrived at the online phase where we only operate in the low-dimensional RB space, agnostic of the snapshot solver method. We have to make sure, however, to choose matching degeneracy settings for the <a href="../../api/#ReducedBasis.FullDiagonalization"><code>FullDiagonalization</code></a> solver in the online phase:</p><pre><code class="language-julia hljs">fulldiag = FullDiagonalization(dm);</code></pre><p>Then we can define an online grid and compute the magnetization at all grid points, again constructing <code>m</code> at an arbitrary parameter point since its coefficient is parameter-independent:</p><pre><code class="language-julia hljs">m_reduced = m()
Δ_online = range(first(Δ), last(Δ); length=100)
hJ_online = range(first(hJ), last(hJ); length=100)
grid_online = RegularGrid(Δ_online, hJ_online)

using Statistics
magnetization = map(grid_online) do μ
    _, φ_rb = solve(rbres.h, rbres.basis.metric, μ, fulldiag)
    mean(u -&gt; abs(dot(u, m_reduced, u)), eachcol(φ_rb))
end;</code></pre><p>Plotting the <code>magnetization</code> on a heatmap, we arrive at the following result:</p><pre><code class="language-julia hljs">using Plots
hm = heatmap(grid_online.ranges[1], grid_online.ranges[2], magnetization&#39;;
             xlabel=raw&quot;$\Delta$&quot;, ylabel=raw&quot;$h/J$&quot;, title=&quot;magnetization&quot;,
             colorbar=true, clims=(0.0, 1.0), leg=false)
params = unique(rbres.basis.parameters)
scatter!(hm, [μ[1] for μ in params], [μ[2] for μ in params];
         markershape=:xcross, color=:springgreen, ms=3.0, msw=2.0)</code></pre><img src="71af1085.svg" alt="Example block output"/><p>We reproduce the ground-state phase diagram, but this time with more magnetization plateaus (due to increased system size) and we see that the greedy algorithm chose different parameter points to solve using DMRG.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../xxz_ed/">« The reduced basis workflow</a><a class="docs-footer-nextpage" href="../xxz_pod/">Basis assembly using Proper Orthogonal Decomposition »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Friday 24 May 2024 09:21">Friday 24 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
